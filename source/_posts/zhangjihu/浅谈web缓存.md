title: 浅谈 WEB 缓存
date: 2018-05-07
categories: zhangjihu
tags: 
- 缓存
- web 缓存
- 浏览器缓存

---

在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。

<!--more-->
## 前言

Web 缓存是指一个 Web 资源（如 html 页面，图片，js，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存根据进来的请求保存输出内容的副本，当再次请求的时候，如果是相同的URL，会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器发送请求。
Web 缓存机制的有多种，在这里主要探讨以浏览器为载体的 HTTP 缓存机制，希望对自己和大家都有所帮助。

## 概述

浏览器缓存（ Brower Caching ）是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，浏览器缓存的优点：

* 减少了冗余的数据传输，节省了网费
* 减少了服务器的负担，大大提升了网站的性能
* 加快了客户端加载网页的速度
    
## 缓存过程分析

浏览器与服务器通信的方式为应答模式，即：浏览器发起 HTTP 请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/fbbc80627083b6bbe7ecb9525a36189434504.webp" alt="">

由上图我们可以知道：
* 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识
* 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中

以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取。

## 浏览器缓存类型

我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分：**强制缓存**和**协商缓存**。
        
### 强制缓存

当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control ，**其中 Cache-Control 优先级比 Expires 高**。

#### Expires

Expires 是 HTTP /1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header ，如：

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/417893a96e4205a4c13acbc58941d25850878.png">

2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header ）；
3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。
4、如果缓存没有命中，浏览器直接向服务器发送请求，Expires Header 在重新加载的时候会被更新。
到了 HTTP /1.1，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 Cache-Control 又是如何控制的呢？

### Cache-Control

在 HTTP /1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：
* public：可以被所有的用户缓存，包括客户端和 CDN 等中间代理服务器，默认值
* private：只能被客户端缓存，不允许 CDN 等中间代理服务器对其缓存，Cache-Control 的默认取值
* no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
* no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存，每次请求该资源直接向服务器发送请求，每次都会下载完整的资源
* max-age=xxx：（单位为s）：缓存内容将在 xxx 秒后失效，当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了
* s-maxage=xxx （单位为s）：同 max-age ，只用于共享缓存（比如 CDN 缓存），覆盖掉 max-age 和 Expires

接下来，我们直接看一个例子，如下：

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header；
2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；
3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/2f10fb6c2edd15f829d36330bee33b6b57447.png" alt="">

4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。

由上面的例子我们可以知道：
* HTTP 响应报文中 expires 的时间值，是一个绝对时间的GMT格式的时间字符串
* HTTP 响应报文中 Cache-Control 为 max-age =7200，是相对值，代表着资源的有效期

由于 Cache-Control 的优先级比 expires ，那么直接根据 Cache-Control 的值进行缓存，意思就是说在 7200 秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。
注：在无法确定客户端的时间是否与服务端的时间同步的情况下， Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。


### 协商缓存

当浏览器对某个资源的请求没有命中强缓存，就会携带缓存标识向服务器发起请求，验证协商缓存是否命中，由服务器根据缓存标识决定是否使用缓存，如果协商缓存命中，请求响应返回的 http 状态为 304。

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/165599b6e70d5fcc1258be192f6db41b36954.png" alt="">

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/0416603a7ed8b6c6d8af6f548a6c570c26337.png" alt="">

查看单个请求的 ResponseHeader，也能看到 304 的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源。

#### 主要有以下两种情况：
协商缓存生效，返回 304 ，如下:

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/cac3ffaa672010fee74692465e9c17f021484.webp" alt="">
>304

协商缓存失效，返回 200 和请求结果结果，如下:

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/76908dc6fb49340ad92d97ff2ed759ba22094.riff" alt="">
>200

同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。

##### 【Last-Modified，If-Modified-Since】:

Last-Modified 是该资源文件最后一次更改时间，服务器会在 response header 里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到 request header 里的 If-Modified-Since 里，服务器在接收到后也会做比对，如果相同则命中协商缓存，具体情况如下：

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：

<img src="http://vfile.meituan.net/xgfe/d5788526358fd1f02278de827d0cc8f481865.png" alt="">

2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：

<img src="http://vfile.meituan.net/xgfe/b150d289f5ec7c2921d175d4aad1dd8a81884.png" alt="">

3、服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容，状态码为 200。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header：
4、浏览器收到 304 的响应后，就会从缓存中加载资源。
5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。

##### 【ETag、If-None-Match】:

1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：

<img src="http://vfile.meituan.net/xgfe/f8e13201a0acfa1c34a07f978ab8eb1560458.png" alt="">

2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header ，这个 header 的值就是上一次请求时返回的 ETag 的值：

<img src="http://vfile.meituan.net/xgfe/b3ee027ffc12d12ee34cfdeaebff931f103431.png" alt="">

3、服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified ，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：
4、浏览器收到 304 的响应后，就会从缓存中加载资源。

##### 为什么要有 Etag

你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？ HTTP 1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：
    • 一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET；
    • 某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比方说 1s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）；
    • 某些服务器不能精确的得到文件的最后修改时间。
Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag ，一致的情况下，才会继续比对 Last-Modified ，最后才决定是否返回 304。

### 强缓存与协商缓存的区别

强缓存与协商缓存的区别可以用下表来表示：

<img src="http://vfile.meituan.net/xgfe/f0eb26fac54900ef2272f4c3e3e233ef20064.png" alt="">

强制缓存优先于协商缓存进行，若强制缓存（ Expires 和 Cache-Control ）生效则直接使用缓存，若不生效则进行协商缓存（ Last-Modified / If-Modified-Since 和 Etag / If-None-Match ），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304 ，继续使用缓存。

### 浏览器缓存过程

1、浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并缓存；
2、下一次加载资源时，先比较当前时间和上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age ，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP 1.1，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求；
3、服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
4、如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；

<img width = "600px" height = "300px" src="http://vfile.meituan.net/xgfe/735836ddebf6bf03fb577902c88afd6925020.webp" alt="">

### 用户行为对缓存的影响

地址栏访问，点击链接跳转是正常用户行为，将会触发浏览器缓存机制，浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容；
F5 刷新，浏览器会设置 max-age =0，跳过强缓存判断，会进行协商缓存判断；
ctrl+F5 刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。

<img src="http://vfile.meituan.net/xgfe/72ef16289230d836b2027eb7f6a6845c27545.png" alt="">

### 已经缓存的响应，如何更新或废弃？

一般情况下，浏览器发出的所有 HTTP 请求会首先被路由到浏览器的缓存，以查看是否缓存了可以用于实现请求的有效响应。如果有匹配的响应，会直接从缓存中读取响应，这样就避免了网络延迟以及传输产生的数据成本。然而，如果我们希望更新或废弃已缓存的响应，该怎么办？
假设我们已经告诉访问者某个 CSS 样式表缓存长达 24 小时（max-age=86400），但是设计人员刚刚提交了一个更新，我们希望所有用户都能使用。我们该如何通知所有访问者缓存的 CSS 副本已过时，需要更新缓存？ 
实际上以前没有请求过该资源的新的用户会得到更新的资源，但是请求过资源的用户将在过期时间达到之前一直得到旧的被缓存的资源，直到他手动的去清理了浏览器的缓存。手动清理浏览器缓存这种事可能只有程序员才会做，那么我们要怎么做才能让用户得到更新后的资源呢？
其实很简单，我们可以在资源的内容更改后，更改资源的网址，强制用户下载新响应。比如在资源链接后添加参数：

<img src="http://vfile.meituan.net/xgfe/29b12a26033d0eccff1a6d503ae8f9f674695.png" alt="">

（有兴趣的可以阅读：https://www.zhihu.com/question/20790576）

## web 缓存作用

1、减少网络带宽消耗
无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。

2、降低服务器压力
给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。

3、减少网络延迟，加快页面打开速度
缓存的使用能够明显加快页面打开速度，提高网页性能，达到更好的体验。

## 其它 web 缓存机制

1、数据库缓存
我们可能听说过 memcached ，它就是一种数据库层面的缓存方案。数据库缓存是指，当 web 应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。

2、CDN 缓存
CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向 CDN 网关发起 Web 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个 CDN 就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。

3、代理服务器缓存
代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 Web 请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。

4、应用层缓存
应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。

## 总结

在前端开发中，浏览器缓存是 web 性能优化的重要方面，是提升 web 性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以对于缓存的应用需要综合考虑。




