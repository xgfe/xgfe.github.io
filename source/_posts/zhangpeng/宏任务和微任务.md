title: 宏任务和微任务
date: 2019-04-16
categories:
- ZHANGPENG
tags:
- 宏任务和微任务
---
本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍事件循环，第二部分是介绍宏任务和微任务。

<!--more-->

## 一、深入事件循环

### 1.宏任务
事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。
宏任务：
（1）创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。
（2）页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。
（3）运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收

### 2.微任务

* 微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。
* 微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。
* 微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续

### 3.事件循环

ECMA的规范没有提及到事件循环，但在HTML规范里却有提及
（1）里面也讨论了宏任务和微任务的概念
（2）ECMA规范提及到了Promise
（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用
事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。
事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。
从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。
当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。
两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。
因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。
所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。
浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。
现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。
```
    在另一个16ms结束前，事件循环执行到"是否需要渲染"的决策的环节。因为更新UI是一个复杂的操作，如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作
    在最后的一个渲染操作完成后大约16ms，事件循环执行到"是否需要进行渲染"的决策环节，在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。
    在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，用户可能会觉得网页挂掉了。
    在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，可能会导致网页的性能低下。  
    <button id="firstButton"></button>  
    <button id="secondButton"></button>
    <script>
    const fristButton = document.getElementById('firstButton')
    const secondButton = document.getElementById('secondButton')
    firstButton.addEventListener("click", function firstHandle(){
        /* Some click runs 8 ms */
    })
    secondButton.addEventListener("click", function secondHandle(){
        /* Some click runs 5 ms */
    })
    /* run 15ms */
    </script>
    主线程javascript代码执行时间需要15ms
    第一个单击事件处理器需要运行8ms
    第二个单击事件处理器需要运行5ms
    让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms,第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript
    代码开始，立刻从DOM获取firstButton和secondButton元素，并注册firstHandle和secondHandle的事件处理器。
    firstButton.addEventListener("click", function firstHandle(){
        /* Some click runs 8 ms */
    })
    secondButton.addEventListener("click", function secondHandle(){
        /* Some click runs 5 ms */
    })
    主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.
    由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。记住，一个任务
    一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。
    在第12ms的时候，
    1.执行主线程javascript代码，执行当前任务。
    2.单击firstButton，单击firstButton的时候，创建事件
    3.单击secondButton,单击secondButton的时候，创建事件
    在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。
    接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。
    最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms,执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，但是对应的事件处理任务在第23ms时才开始执行。

```
### 4.宏任务和微任务
```
<button id="firstButton"></button>  
<button id="secondButton"></button>
<script>
const fristButton = document.getElementById('firstButton')
const secondButton = document.getElementById('secondButton')
firstButton.addEventListener("click", function firstHandle(){
    Promise.resolve().then(()=>{
        /* Some run 4ms */
    })
    /* Some click runs 8 ms */
})
secondButton.addEventListener("click", function secondHandle(){
    /* Some click runs 5 ms */
})
/* run 15ms */
</script>     
第5ms单击firstButton
第12m单击secondButton
firstButton 的单击事件处理函数firstHandle需要执行8ms
secondButton 的单击事件的处理函数secondHandle需要执行5ms
在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。
我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。
在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，单击firstButton和secondButton按钮这两个任务处于等待状态，但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，处理firstButton按钮单机相关任务的代码如下。
firstButton.addEventListener("click", function firstHandle(){
    Promise.resolve().then(()=>{
        /* Some run 4ms */
    })
    /* Some click runs 8 ms */
})
firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，添加了一个微任务处理PROMISE成功兑现。
如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。
正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，在更早的队列中secondButton单击任务执行完毕则继续等待。
当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。可以在主线程和第一个按钮单击任务之间重新渲染页面，但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。
注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意
```
### 5.计时器
计时器是能延迟一段代码的运行，延迟时长是指定的时长，将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，在事件循环中执行计时器。
```
<button id="myButton"></button>
<script>
setTimeout(function timeoutHandle(){
    /* run 6ms */
},10)
setInterval(function intervalHandle(){
    /* run 8ms */
},10)
const myButton = document.getElementById('myButton')
myButton.addEventListener('click', function clickHandle(){
    /* run 10ms */
})
/* run 18ms */
</script>
在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。
setTimeout(function timeoutHandle(){
    /* run 6ms */
},10)
延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。
setInterval(function intervalHandle(){
    /* run 8ms */
},10)
间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。
const myButton = document.getElementById('myButton')
myButton.addEventListener('click', function clickHandle(){
    /* run 10ms */
})
/* run 18ms */
假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，
在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，发生了3件重要的事件。
在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.计时器的引用保存在浏览器。
在6ms，单击鼠标
在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。
从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，计时器事件与input输入框的输入事件类似，都会被添加到队列中。注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。
运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，这意味着单击事件处理器开始执行，setTimeout函数只到期一次，setInterval函数则不同，setTnterval会持续执行到被清除，因此，在第20ms的时候，setInterval又一次触发，但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发，但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。
单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，第28ms,事件循环进行下一次迭代，执行延迟计时器任务。
setTimeout(function timeoutHandle(){
    /* run 6ms */
},10)
期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。
这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，因为队列中已经有一个与之相匹配的间隔计时器，在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，然后进入下一个事件循环迭代。
最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。
间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，此时，由于间隔处理器正在执行，不是在队列中等待，设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，每一个任务的执行时间有可能不同，一个接一个的完成。
最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。
```