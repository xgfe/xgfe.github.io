<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2019-05-05T02:41:48.396Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Category 与Extension 相关知识</title>
    <link href="http://xgfe.github.io/2019/05/05/wanglibin/category%E4%B8%8EExtension%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://xgfe.github.io/2019/05/05/wanglibin/category与Extension相关知识/</id>
    <published>2019-05-05T02:41:48.396Z</published>
    <updated>2019-05-05T02:41:48.396Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Category 和 Extension 的相关知识以及使用。<br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul><li>Category的背景和概念</li><li>Category的声明及实现</li><li>Category的使用</li><li>Category扩展属性（变量）</li></ul><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><ul><li>Extension的格式</li><li>Extension的实现</li></ul><h2 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><h3 id="一、Category"><a href="#一、Category" class="headerlink" title="一、Category"></a>一、Category</h3><h4 id="1、Category的背景和概念"><a href="#1、Category的背景和概念" class="headerlink" title="1、Category的背景和概念"></a>1、Category的背景和概念</h4><p>在日常开发中，经常需要对已有类进行功能上的扩展，在学习“类别”之前，常用的类扩展方式有以下三种：</p><ul><li>原有类的修改</li><li>继承</li><li>protocol（协议）</li></ul><p>针对以上三种扩展方式，</p><ol><li><p>第一种为最原始的方法；</p></li><li><p>第二种在继承父类的同时，也扩展自己，包括（方法和变量）。但是在面向对象的开发原则中“优先使用组合慎用继承”，因为继承在一定程度上破坏了封装性、子类随父类变动。</p></li><li><p>第三种协议，主要是依靠实现类的具体方法实现，当扩展功能时，需要修改原有类，协议定义过多，实现类过于庞大。</p></li></ol><p>那么，在oc中，当我们想避免上述两种扩展方式的缺点，又想只对现有类进行扩展些方法，并且不用去修改原有类以及使用它的地方的代码，就用到了Category（类别）。</p><p>类别是OC的特有语法，可以通过在类上声明和实现方法来扩展现有类的功能。原则上只能增加方法（包括对象方法和类方法），不能增加成员变量。</p><h4 id="2、Category的声明及实现"><a href="#2、Category的声明及实现" class="headerlink" title="2、Category的声明及实现"></a>2、Category的声明及实现</h4><pre><code>@interface 需扩展的类 （类别的名称）-（void）appendMethod;@end@implementation 需扩展的类 （类别的名称）-（void）appendMethod{}@end</code></pre><h4 id="3、Category的使用"><a href="#3、Category的使用" class="headerlink" title="3、Category的使用"></a>3、Category的使用</h4><p>如果需要扩展一个类，定义好此类的Category ，则可以通过该类的对象直接调用Category中的扩展方法。与此同时，在Category中也可以访问原有类.h中的属性和方法。</p><p>.h文件：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface pson : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;- (void) run;+ (void) jump;@end</code></pre><p>.m文件</p><pre><code>#import &quot;pson.h&quot;@implementation pson-(void) run{    NSLog(@&quot;run&quot;);}+(void) jump{    NSLog(@&quot;jump&quot;);}@end</code></pre><p>为pson类添加eat方法，Category的.m文件如下所示：</p><p>pson+eat.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;@end</code></pre><p>pson+eat.m文件</p><pre><code>#import &quot;pson+eat.h&quot;@implementation pson (eat)-(void) eat{   //调用原有类的公共方法[self run];//调用原有类的非私有属性NSLog(@&quot;%@&quot;,self.name);}+(void) drink{    NSLog(@&quot;drink&quot;);}@end</code></pre><p>在main方法中</p><pre><code>pson *me = [[pson alloc] init];    [me run];    //调用扩展类中的对象方法    [me eat];    //调用扩展类中的类方法    [pson drink]</code></pre><h4 id="4、Category扩展属性（变量）"><a href="#4、Category扩展属性（变量）" class="headerlink" title="4、Category扩展属性（变量）"></a>4、Category扩展属性（变量）</h4><p>由于Category本质上是个指向类型的结构体指针，在结构体中只有方法的列表，没有属性的列表，所以理论上只能增加方法不能增加属性。</p><p>如何通过Category来扩展属性呢？</p><p>无法添加属性的根本原因是：在Category中@property声明属性，系统不会生成_成员变量和setter、getter。</p><p>解决方法：手动添加setter和getter方法，采用的就是：关联引用（objc_setAssociatedObject和objc_getAssociatedObject）</p><p>其中，</p><p>objc_setAssociatedObject，接收4个参数：想关联到数据的对象、获取数据的键值、存储引用的值、关联的策略；</p><p>objc_getAssociatedObject，接收2个参数：关联到数据的对象、键值</p><p>常见的关联策略，如下表所示：</p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>OBJC <em> ASSOCIATION </em> ASSIGN</td><td>指定值将被简单赋值、没有保留和释放</td></tr><tr><td>OBJC <em> ASSOCIATION </em> RETAIN _ NONATOMIC</td><td>指定值通过非线程安全的方式赋值并保留</td></tr><tr><td>OBJC <em> ASSOCIATION </em> COPY _ NONATOMIC</td><td>指定值通过非线程安全的方式复制</td></tr><tr><td>OBJC <em> ASSOCIATION </em> RETAIN</td><td>指定值通过线程安全的方式赋值并保留</td></tr><tr><td>OBJC <em> ASSOCIATION </em> COPY</td><td>指定值通过线程安全的方式复制</td></tr></tbody></table><p>具体实现例子如下所示：</p><p>Category的.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;+(void) drink;@end</code></pre><p>Category的.m文件</p><pre><code>#import &quot;pson+eat.h&quot;#import &quot;objc/runtime.h&quot;static NSString *key = @&quot;personEatKey&quot;;@implementation pson (eat)-(void) eat{    NSLog(@&quot;eat&quot;);}-(void) setFood:(NSString *)food{    objc_setAssociatedObject(self, &amp;key, food,     OBJC_ASSOCIATION_COPY);}-(NSString *) food{    return objc_getAssociatedObject(self, &amp;key);}@end</code></pre><p>main方法中的使用如下：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &quot;pson.h&quot;#import &quot;pson+eat.h&quot;int main(int argc, const char * argv[]) {    @autoreleasepool {        pson *me = [[pson alloc] init];        [me eat];        me.food = @&quot;鸡蛋&quot;;        NSLog(@&quot;%@&quot;,me.food);    }    return 0;}</code></pre><h3 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、Extension</h3><p>Extension 是Category的特例，少了类别的名称，是匿名分类。声明私有方法和属性的机制。具体实现在原有类的.m文件中。</p><h4 id="1、Extension的格式"><a href="#1、Extension的格式" class="headerlink" title="1、Extension的格式"></a>1、Extension的格式</h4><pre><code>@interface XXX ()    //私有属性    //私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）@end</code></pre><h4 id="2、Extension的实现"><a href="#2、Extension的实现" class="headerlink" title="2、Extension的实现"></a>2、Extension的实现</h4><ul><li>通过单独的.h声明，在原有类的.m中导入。</li><li>直接在原有类的.m中使用。</li></ul><h2 id="Category和Extension的区别-1"><a href="#Category和Extension的区别-1" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><ul><li>Category原则上只能增加方法；而Extension方法和变量都可以。</li><li>Extension声明方法没有被实现，编译器报警。Category在运行时添加、Extension是编译阶段。</li><li>Extension没有自己独立的实现部分。</li><li>Extension是私有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Category 和 Extension 的相关知识以及使用。&lt;br&gt;
    
    </summary>
    
      <category term="wanglibin" scheme="http://xgfe.github.io/categories/wanglibin/"/>
    
    
      <category term="OC" scheme="http://xgfe.github.io/tags/OC/"/>
    
      <category term="Category" scheme="http://xgfe.github.io/tags/Category/"/>
    
      <category term="Extension" scheme="http://xgfe.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2019/04/16/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2019/04/16/zhangpeng/宏任务和微任务/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.407Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。</p><a id="more"></a><h2 id="一、宏任务和微任务"><a href="#一、宏任务和微任务" class="headerlink" title="一、宏任务和微任务"></a>一、宏任务和微任务</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：</p><ul><li>创建主文档对象,解析HTML,执行主线或者全局的javascript的代码,更改url以及各种事件。</li><li>页面加载,输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。</li><li>运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收。</li></ul><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><p>微任务：</p><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br> 事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。</p><p> 事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br> 从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。</p><p> 当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br> 两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br> 因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。</p><p> 所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br> 浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br> 现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，</span><br><span class="line">如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，</span><br><span class="line">在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，</span><br><span class="line">且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，</span><br><span class="line">反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，</span><br><span class="line">用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，</span><br><span class="line">可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，</span><br><span class="line">我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms，</span><br><span class="line">第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，</span><br><span class="line">并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。</span><br><span class="line">记住，一个任务一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，</span><br><span class="line">等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，</span><br><span class="line">等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line"></span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，</span><br><span class="line">任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，</span><br><span class="line">UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line"></span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，</span><br><span class="line">secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，</span><br><span class="line">接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，</span><br><span class="line">浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms，</span><br><span class="line">执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，</span><br><span class="line">但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms。</span><br><span class="line"></span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms。</span><br><span class="line"></span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。</span><br><span class="line">因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line"></span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，</span><br><span class="line">但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，</span><br><span class="line">需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line"></span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，</span><br><span class="line">单击firstButton和secondButton按钮这两个任务处于等待状态，</span><br><span class="line">但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，</span><br><span class="line">此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，</span><br><span class="line">若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，</span><br><span class="line">处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line"></span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，</span><br><span class="line">此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，</span><br><span class="line">第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，</span><br><span class="line">此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，</span><br><span class="line">在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，</span><br><span class="line">添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，</span><br><span class="line">微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，</span><br><span class="line">事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line"></span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，</span><br><span class="line">在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line"></span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。</span><br><span class="line">可以在主线程和第一个按钮单击任务之间重新渲染页面，</span><br><span class="line">但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，</span><br><span class="line">所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，</span><br><span class="line">事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意。</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，<br>将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，<br>在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line"></span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，</span><br><span class="line">发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.</span><br><span class="line">计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标。</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line"></span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。</span><br><span class="line">新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，</span><br><span class="line">该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，</span><br><span class="line">计时器事件与input输入框的输入事件类似，都会被添加到队列中。</span><br><span class="line">注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，</span><br><span class="line">因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，</span><br><span class="line">3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，</span><br><span class="line">这意味着单击事件处理器开始执行，setTimeout函数只到期一次，</span><br><span class="line">setInterval函数则不同，setTnterval会持续执行到被清除，</span><br><span class="line">因此，在第20ms的时候，setInterval又一次触发，</span><br><span class="line">但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发。</span><br><span class="line">但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，</span><br><span class="line">第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line"></span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，</span><br><span class="line">至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，</span><br><span class="line">而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，</span><br><span class="line">但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，</span><br><span class="line">因为队列中已经有一个与之相匹配的间隔计时器，</span><br><span class="line">在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，</span><br><span class="line">然后进入下一个事件循环迭代。</span><br><span class="line"></span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,</span><br><span class="line">又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line"></span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，</span><br><span class="line">此时，由于间隔处理器正在执行，不是在队列中等待，</span><br><span class="line">设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，</span><br><span class="line">每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line"></span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，</span><br><span class="line">事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，</span><br><span class="line">间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，</span><br><span class="line">回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要是介绍宏任务和微任务，第二部分是介绍事件循环。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>函数防抖与函数节流</title>
    <link href="http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/"/>
    <id>http://xgfe.github.io/2019/03/09/yangfan/debounce&amp;throttle/</id>
    <published>2019-03-09T08:15:00.000Z</published>
    <updated>2019-05-05T02:41:48.402Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。</p><a id="more"></a><h2 id="Debounce（防抖）"><a href="#Debounce（防抖）" class="headerlink" title="Debounce（防抖）"></a>Debounce（防抖）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>当调用动作过n毫秒后，才会执行该动作，若在这n毫秒内又调用此动作则将重新计算执行时间。</p></blockquote><h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>用户注册时验证用户名是否被占用为例在输入的时候就在判断这个用户名是否已被注册。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数前<br><img src="/uploads/yangfan/DebounceThrottle/debouncebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用防抖函数后<br><img src="/uploads/yangfan/DebounceThrottle/debounceafter.gif" width="400px"><br></div><br></div><p>使用防抖函数前做法存在明显缺陷当用户输入发生变化的时候，就请求判断了，不仅对服务器的压力增大了，而且用户在输入中时频繁的校验提示中断用户交互明显降低了用户体验。而理想的做法应该是，用户输入发生变化后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。而函数防抖所做的工作就是延迟一段时间去执行函数而在延迟期间又调用了此动作则重新计时。</p><h3 id="DemoCode"><a href="#DemoCode" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"ordinary"</span>&gt;</span>普通<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'ordinary'</span> <span class="attr">id</span>=<span class="string">'ordinary'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"debounce"</span>&gt;</span>防抖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">'debounce'</span> <span class="attr">id</span>=<span class="string">'debounce'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`ajax requestDtae:<span class="subst">$&#123;e.target.value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ordinaryInput = <span class="built_in">document</span>.getElementById(<span class="string">'ordinary'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceInput = <span class="built_in">document</span>.getElementById(<span class="string">'debounce'</span>);</span><br><span class="line"><span class="keyword">const</span> debounceAjax = _.debounce(ajax, <span class="number">1000</span>)</span><br><span class="line">ordinaryInput.addEventListener(<span class="string">'keyup'</span>, ajax);</span><br><span class="line">debounceInput.addEventListener(<span class="string">'keyup'</span>, debounceAjax);</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">            func(args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Throttle（节流）"><a href="#Throttle（节流）" class="headerlink" title="Throttle（节流）"></a>Throttle（节流）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></blockquote><h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><p>在瀑布流式布局的页面中，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。在发生滚动时就需要判断页面是否滚动到底部。</p><div style="overflow:hidden;"><br><div style="float:left;width:50%;text-align: center;"><br>使用节流函数前<br><img src="/uploads/yangfan/DebounceThrottle/throttlebefore.gif" width="400px"><br></div><div style="float:left;width:50%;text-align: center;"><br>使用节流函数后<br><img src="/uploads/yangfan/DebounceThrottle/throttleafter.gif" width="400px"><br></div><br></div><p>使用节流函数前明显缺点是消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数。</p><h3 id="DemoCode-1"><a href="#DemoCode-1" class="headerlink" title="DemoCode"></a>DemoCode</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollAnimation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`scroll bodyY:<span class="subst">$&#123;body.getBoundingClientRect().y&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> throttleScrollAnimation = _.throttle(scrollAnimation, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//window.addEventListener('scroll', scrollAnimation);</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, throttleScrollAnimation);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 传入函数</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; wait 表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125; 返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">let</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        <span class="keyword">if</span> (curr - start &gt;= wait) &#123;</span><br><span class="line">            func(args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                func(args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果还是不能完全体会 debounce 和 throttle 的差异，可以到 <a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">这个页面</a> 看一下两者可视化的比较。<br>在实际的开发中根据根据需求的不同合理使用 debounce 或 throttle。<br>例如：在模糊查询时使用 debounce 在无限滚动时使用 throttle。（requestAnimationFrame）</p><h2 id="附lodash实现代码"><a href="#附lodash实现代码" class="headerlink" title="附lodash实现代码"></a>附lodash实现代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isObject <span class="keyword">from</span> <span class="string">'./isObject.js'</span></span><br><span class="line"><span class="keyword">import</span> root <span class="keyword">from</span> <span class="string">'./.internal/root.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a debounced function that delays invoking `func` until after `wait`</span></span><br><span class="line"><span class="comment"> * milliseconds have elapsed since the last time the debounced function was</span></span><br><span class="line"><span class="comment"> * invoked, or until the next browser frame is drawn. The debounced function</span></span><br><span class="line"><span class="comment"> * comes with a `cancel` method to cancel delayed `func` invocations and a</span></span><br><span class="line"><span class="comment"> * `flush` method to immediately invoke them. Provide `options` to indicate</span></span><br><span class="line"><span class="comment"> * whether `func` should be invoked on the leading and/or trailing edge of the</span></span><br><span class="line"><span class="comment"> * `wait` timeout. The `func` is invoked with the last arguments provided to the</span></span><br><span class="line"><span class="comment"> * debounced function. Subsequent calls to the debounced function return the</span></span><br><span class="line"><span class="comment"> * result of the last `func` invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * **Note:** If `leading` and `trailing` options are `true`, `func` is</span></span><br><span class="line"><span class="comment"> * invoked on the trailing edge of the timeout only if the debounced function</span></span><br><span class="line"><span class="comment"> * is invoked more than once during the `wait` timeout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred</span></span><br><span class="line"><span class="comment"> * until the next tick, similar to `setTimeout` with a timeout of `0`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `wait` is omitted in an environment with `requestAnimationFrame`, `func`</span></span><br><span class="line"><span class="comment"> * invocation will be deferred until the next frame is drawn (typically about</span></span><br><span class="line"><span class="comment"> * 16ms).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)</span></span><br><span class="line"><span class="comment"> * for details over the differences between `debounce` and `throttle`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @since 0.1.0</span></span><br><span class="line"><span class="comment"> * @category Function</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; func The function to debounce.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [wait=0]</span></span><br><span class="line"><span class="comment"> *  The number of milliseconds to delay; if omitted, `requestAnimationFrame` is</span></span><br><span class="line"><span class="comment"> *  used (if available).</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; [options=&#123;&#125;] The options object.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.leading=false]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the leading edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; [options.maxWait]</span></span><br><span class="line"><span class="comment"> *  The maximum time `func` is allowed to be delayed before it's invoked.</span></span><br><span class="line"><span class="comment"> * @param &#123;boolean&#125; [options.trailing=true]</span></span><br><span class="line"><span class="comment"> *  Specify invoking on the trailing edge of the timeout.</span></span><br><span class="line"><span class="comment"> * @returns &#123;Function&#125; Returns the new debounced function.</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Avoid costly calculations while the window size is in flux.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('resize', debounce(calculateLayout, 150))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Invoke `sendMail` when clicked, debouncing subsequent calls.</span></span><br><span class="line"><span class="comment"> * jQuery(element).on('click', debounce(sendMail, 300, &#123;</span></span><br><span class="line"><span class="comment"> *   'leading': true,</span></span><br><span class="line"><span class="comment"> *   'trailing': false</span></span><br><span class="line"><span class="comment"> * &#125;))</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Ensure `batchLog` is invoked once after 1 second of debounced calls.</span></span><br><span class="line"><span class="comment"> * const debounced = debounce(batchLog, 250, &#123; 'maxWait': 1000 &#125;)</span></span><br><span class="line"><span class="comment"> * const source = new EventSource('/stream')</span></span><br><span class="line"><span class="comment"> * jQuery(source).on('message', debounced)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Cancel the trailing debounced invocation.</span></span><br><span class="line"><span class="comment"> * jQuery(window).on('popstate', debounced.cancel)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // Check for pending invocations.</span></span><br><span class="line"><span class="comment"> * const status = debounced.pending() ? "Pending..." : "Ready"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastArgs, </span><br><span class="line">        lastThis,</span><br><span class="line">        maxWait,</span><br><span class="line">        result,</span><br><span class="line">        timerId,</span><br><span class="line">        lastCallTime</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lastInvokeTime = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> maxing = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bypass `requestAnimationFrame` by explicitly setting `wait=0`.</span></span><br><span class="line">    <span class="keyword">const</span> useRAF = (!wait &amp;&amp; wait !== <span class="number">0</span> &amp;&amp; <span class="keyword">typeof</span> root.requestAnimationFrame === <span class="string">'function'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wait = +wait || <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = !!options.leading</span><br><span class="line">        maxing = <span class="string">'maxWait'</span> <span class="keyword">in</span> options</span><br><span class="line">        maxWait = maxing ? <span class="built_in">Math</span>.max(+options.maxWait || <span class="number">0</span>, wait) : maxWait</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">invokeFunc</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> args = lastArgs</span><br><span class="line">        <span class="keyword">const</span> thisArg = lastThis</span><br><span class="line"></span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        result = func.apply(thisArg, args)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">startTimer</span>(<span class="params">pendingFunc, wait</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            root.cancelAnimationFrame(timerId);</span><br><span class="line">            <span class="keyword">return</span> root.requestAnimationFrame(pendingFunc)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setTimeout(pendingFunc, wait)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancelTimer</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (useRAF) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.cancelAnimationFrame(id)</span><br><span class="line">        &#125;</span><br><span class="line">        clearTimeout(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leadingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Reset any `maxWait` timer.</span></span><br><span class="line">        lastInvokeTime = time</span><br><span class="line">        <span class="comment">// Start the timer for the trailing edge.</span></span><br><span class="line">        timerId = startTimer(timerExpired, wait)</span><br><span class="line">        <span class="comment">// Invoke the leading edge.</span></span><br><span class="line">        <span class="keyword">return</span> leading ? invokeFunc(time) : result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remainingWait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line">        <span class="keyword">const</span> timeWaiting = wait - timeSinceLastCall</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxing ?</span><br><span class="line">            <span class="built_in">Math</span>.min(timeWaiting, maxWait - timeSinceLastInvoke) :</span><br><span class="line">            timeWaiting</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">shouldInvoke</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastCall = time - lastCallTime</span><br><span class="line">        <span class="keyword">const</span> timeSinceLastInvoke = time - lastInvokeTime</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Either this is the first call, activity has stopped and we're at the</span></span><br><span class="line">        <span class="comment">// trailing edge, the system time has gone backwards and we're treating</span></span><br><span class="line">        <span class="comment">// it as the trailing edge, or we've hit the `maxWait` limit.</span></span><br><span class="line">        <span class="comment">// timeSinceLastCall &lt; 0 修改系统时间时不会出现bug</span></span><br><span class="line">        <span class="keyword">return</span> (lastCallTime === <span class="literal">undefined</span> || (timeSinceLastCall &gt;= wait) ||</span><br><span class="line">            (timeSinceLastCall &lt; <span class="number">0</span>) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timerExpired</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">if</span> (shouldInvoke(time)) &#123;</span><br><span class="line">            <span class="keyword">return</span> trailingEdge(time)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Restart the timer.</span></span><br><span class="line">        timerId = startTimer(timerExpired, remainingWait(time))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trailingEdge</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">        timerId = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only invoke if we have `lastArgs` which means `func` has been</span></span><br><span class="line">        <span class="comment">// debounced at least once.</span></span><br><span class="line">        <span class="keyword">if</span> (trailing &amp;&amp; lastArgs) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokeFunc(time)</span><br><span class="line">        &#125;</span><br><span class="line">        lastArgs = lastThis = <span class="literal">undefined</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timerId !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">            cancelTimer(timerId)</span><br><span class="line">        &#125;</span><br><span class="line">        lastInvokeTime = <span class="number">0</span></span><br><span class="line">        lastArgs = lastCallTime = lastThis = timerId = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">flush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId === <span class="literal">undefined</span> ? result : trailingEdge(<span class="built_in">Date</span>.now())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pending</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timerId !== <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> time = <span class="built_in">Date</span>.now()</span><br><span class="line">        <span class="keyword">const</span> isInvoking = shouldInvoke(time)</span><br><span class="line"></span><br><span class="line">        lastArgs = args</span><br><span class="line">        lastThis = <span class="keyword">this</span></span><br><span class="line">        lastCallTime = time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInvoking) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> leadingEdge(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxing) &#123;</span><br><span class="line">                <span class="comment">// Handle invocations in a tight loop.</span></span><br><span class="line">                timerId = startTimer(timerExpired, wait)</span><br><span class="line">                <span class="keyword">return</span> invokeFunc(lastCallTime)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerId === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            timerId = startTimer(timerExpired, wait)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    debounced.cancel = cancel</span><br><span class="line">    debounced.flush = flush</span><br><span class="line">    debounced.pending = pending</span><br><span class="line">    <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> leading = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> trailing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> func !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Expected a function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isObject(options)) &#123;</span><br><span class="line">        leading = <span class="string">'leading'</span> <span class="keyword">in</span> options ? !!options.leading : leading</span><br><span class="line">        trailing = <span class="string">'trailing'</span> <span class="keyword">in</span> options ? !!options.trailing : trailing</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> debounce(func, wait, &#123;</span><br><span class="line">        leading,</span><br><span class="line">        trailing,</span><br><span class="line">        <span class="string">'maxWait'</span>: wait,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a></li><li><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中,我们经常以各种方式控制事件的触发。防抖和节流可以使我们在实现功能的同时提升用户体验和页面性能。接下来我将从概念、应用场景、及简单的代码实现来介绍防抖和节流。&lt;/p&gt;
    
    </summary>
    
      <category term="yangfan" scheme="http://xgfe.github.io/categories/yangfan/"/>
    
    
      <category term="javascript" scheme="http://xgfe.github.io/tags/javascript/"/>
    
      <category term="debounce&amp;throttle" scheme="http://xgfe.github.io/tags/debounce-throttle/"/>
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Dagger2 使用及原理分析</title>
    <link href="http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/"/>
    <id>http://xgfe.github.io/2019/02/23/wangwenming/Dagger2/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。<br><a id="more"></a><br>那么问题来了，什么是依赖注入？</p><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>—摘自百度百科</p></blockquote><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在日常编码中经常会有类之间的依赖，为了方便理解，我们举个例子。手机类Phone包含了摄像头Camera组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        mCamera = new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到 Phone 和 Carmera 是耦合的，Phone 需要知道 Camera 的实现类 BackCamera 的存在，一旦 Camera 的实现变为其他，比如 FrontCamera 时，我们还需要修改 Phone 的构造方法。类似问题就可以使用依赖注入来解决。依赖注入的常用方法有构造方法注入和 setter 方法注入，两种方式都可以对 Phone 和 Camera 解耦，使得 Phone 无需关注 Camera 的实现，即使 Camera 的类型变了也无需修改 Phone 的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">    private Camera mCamera;</span><br><span class="line">    </span><br><span class="line">    public Phone(Camera camera) &#123;</span><br><span class="line">        mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCamera(Camera camera) &#123;</span><br><span class="line">        this.mCamera = camera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Component-和-Inject"><a href="#Component-和-Inject" class="headerlink" title="@Component 和 @Inject"></a>@Component 和 @Inject</h3><p>那使用 Dagger2 该如何注入呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BackCamera implements Camera &#123;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getCameraType() &#123;</span><br><span class="line">        return &quot;后置摄像头&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public BackCamera mCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到首先需要声明一个 @Component，然后需要在 BackCamera 的构造方法前增加注解 @Inject，接着在 Phone 的 mCamera 前增加 @Inject 以及构造方法中调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，几者间关系如下：</p><p><img src="/uploads/wangwenming/dagger-1.png" alt=""></p><h3 id="Module-和-Provides"><a href="#Module-和-Provides" class="headerlink" title="@Module 和 @Provides"></a>@Module 和 @Provides</h3><p>那么问题来了，@Inject 只能标记构造方法，如果需要注入的是来自三方库的对象怎么办呢？这就需要用到 @Module，下面我们用 @Module 改造下上面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    public BackCamera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component(modules = &#123;CameraModule.class&#125;)</span><br><span class="line">public interface PhoneComponent &#123;</span><br><span class="line">    void inject(Phone phone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@Module 和 @Provides 配合可以实现对三方库对象的注入。</p><h3 id="Named-和-Qualifier"><a href="#Named-和-Qualifier" class="headerlink" title="@Named 和 @Qualifier"></a>@Named 和 @Qualifier</h3><p>@Qualifier 是限定符用于自定义注解，@Named 是 @Qualifier 的一种实现。在一些情况下我们需要两个有相同父类或实现同一接口的依赖，当需求方使用的又是他们父类时，Component 就不知道到底提供哪一个了。还是拿手机举例，我们在原有基础上增加一个前置摄像头。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Module</span><br><span class="line">public class CameraModule &#123;</span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera provideBackCamera() &#123;</span><br><span class="line">        return new BackCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Provides</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera provideFrontCamera() &#123;</span><br><span class="line">        return new FrontCamera();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Phone &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;front&quot;)</span><br><span class="line">    public Camera mFrontCamera;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    @Named(&quot;back&quot;)</span><br><span class="line">    public Camera mBackCamera;</span><br><span class="line"></span><br><span class="line">    public Phone() &#123;</span><br><span class="line">        DaggerPhoneComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为 Module 中的 provide 方法加上 @Named 注解，然后在需要使用的地方加上对应的 @Named 注解。上面例子同样可以使用 @Qualifier 来实现，使用 @Qualifier 定义两个运行时注解 @Front 和 @Back，使用两个注解替换上面的 @Named 注解即可。</p><h3 id="Singleton-和-Scope"><a href="#Singleton-和-Scope" class="headerlink" title="@Singleton 和 @Scope"></a>@Singleton 和 @Scope</h3><p>@Scope 同样用于自定义注解，我能可以通过 @Scope 自定义的注解来限定注解作用域，实现局部的单例；@Singleton 是 @Scope 的一个实现。在一些场景下我们需要使用单例，@Singleton 和 @Scope 可以帮助我们实现局部单例。为什么说是局部单例呢，因为 @Singleton 或 @Scope 能保证在对应的 Component 下是单例的，如果需要全局的单例，我们就需要其他手段保证 Component 是单例。下面看个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Singleton</span><br><span class="line">public interface AppComponent &#123;</span><br><span class="line">    void inject(App app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Singleton</span><br><span class="line">public class Logger &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    public Logger()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;Logger&quot;, this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger;</span><br><span class="line"></span><br><span class="line">    @Inject</span><br><span class="line">    Logger logger2;</span><br><span class="line"></span><br><span class="line">    public App()&#123;</span><br><span class="line">        DaggerAppComponent.create().inject(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessage() &#123;</span><br><span class="line">        Log.d(&quot;App&quot;, &quot;app:&quot; + this);</span><br><span class="line">        logger.printMessage();</span><br><span class="line">        logger2.printMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 @Singleton 标注 Component 和需要注入的类即可。在上面的例子中，如果调用 App 的 printMessage 方法可以看到 logger 和 logger2 为同一对象，对于不同 App 对象的 logger 则是不同对象。当然我们也可以使用 @Scope 自定义一个注解来实现局部注解，来替换 @Singleton。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>前面简单介绍了 Dagger2 使用，接下来我们分析一下实现原理。Dagger2 在编译时根据注解生成一些辅助类，接下来我们具体分析下生成的辅助类。辅助类可以通过 DaggerXXXComponent 来快速定位。上面两个例子对应生成辅助类如下：</p><p><img src="/uploads/wangwenming/dagger-2.png" alt=""></p><p>简单来看辅助类和注解对应关系很明显，拿手机的例子来说对应关系如下：</p><table><thead><tr><th style="text-align:left">辅助类</th><th style="text-align:left">注解</th></tr></thead><tbody><tr><td style="text-align:left">BackCamera_Factory</td><td style="text-align:left">BackCamera 构造方法的 @Inject</td></tr><tr><td style="text-align:left">CameraModule_ProvideBackCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">CameraModule_ProvideFrontCameraFactory</td><td style="text-align:left">CameraModule 的 @Provides</td></tr><tr><td style="text-align:left">DaggerPhoneComponent</td><td style="text-align:left">PhoneComponent 的 @Component</td></tr><tr><td style="text-align:left">Phone_MembersInjector</td><td style="text-align:left">Phone 对应的 @Inject</td></tr></tbody></table><p>原始类以及辅助类类图如下：</p><p><img src="/uploads/wangwenming/dagger-3.png" alt=""></p><p>接下来我们分析下具体的注入过程，首先 Phone 中会调用 <strong>DaggerPhoneComponent.create().inject(this)</strong>，我们来看下 DaggerPhoneComponent 的源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">@Generated(</span><br><span class="line">  value = &quot;dagger.internal.codegen.ComponentProcessor&quot;,</span><br><span class="line">  comments = &quot;https://google.github.io/dagger&quot;</span><br><span class="line">)</span><br><span class="line">public final class DaggerPhoneComponent implements PhoneComponent &#123;</span><br><span class="line">  private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">  private DaggerPhoneComponent(Builder builder) &#123;</span><br><span class="line">    initialize(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static Builder builder() &#123;</span><br><span class="line">    return new Builder();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static PhoneComponent create() &#123;</span><br><span class="line">    return new Builder().build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">  private void initialize(final Builder builder) &#123;</span><br><span class="line">    this.cameraModule = builder.cameraModule;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void inject(Phone phone) &#123;</span><br><span class="line">    injectPhone(phone);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private Phone injectPhone(Phone instance) &#123;</span><br><span class="line">    Phone_MembersInjector.injectMFrontCamera(</span><br><span class="line">        instance, CameraModule_ProvideFrontCameraFactory.proxyProvideFrontCamera(cameraModule));</span><br><span class="line">    Phone_MembersInjector.injectMBackCamera(</span><br><span class="line">        instance, CameraModule_ProvideBackCameraFactory.proxyProvideBackCamera(cameraModule));</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static final class Builder &#123;</span><br><span class="line">    private CameraModule cameraModule;</span><br><span class="line"></span><br><span class="line">    private Builder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public PhoneComponent build() &#123;</span><br><span class="line">      if (cameraModule == null) &#123;</span><br><span class="line">        this.cameraModule = new CameraModule();</span><br><span class="line">      &#125;</span><br><span class="line">      return new DaggerPhoneComponent(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Builder cameraModule(CameraModule cameraModule) &#123;</span><br><span class="line">      this.cameraModule = Preconditions.checkNotNull(cameraModule);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DaggerPhoneComponent 在创建时首先会创建一个 CameraModule，在进行注入时首先会调用工厂的代理方法最终调用 Module 中对应 @Provides 的方法创建对象，然后通过 Phone_MembersInjector 将上面创建的对象进行注入，工厂与 Injector 核心代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 工厂类核心</span><br><span class="line"> public static Camera proxyProvideFrontCamera(CameraModule instance) &#123;</span><br><span class="line">    return Preconditions.checkNotNull(</span><br><span class="line">        instance.provideFrontCamera(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// Injector 核心</span><br><span class="line"> public static void injectMBackCamera(Phone instance, Camera mBackCamera) &#123;</span><br><span class="line">    instance.mBackCamera = mBackCamera;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 Dagger2 的基本使用并从辅助代码的源码层面进行了原理分析。关于从注解到辅助代码的生成并没有介绍，感兴趣的同学可以自行查阅注解处理器相关知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Dagger2 是一个编译时静态依赖注入框架，是由 Google 在Square开源的 Dagger 基础上进行修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="wangwenming" scheme="http://xgfe.github.io/categories/wangwenming/"/>
    
    
      <category term="dagger2" scheme="http://xgfe.github.io/tags/dagger2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈当Swift中defer和inout同时起作用</title>
    <link href="http://xgfe.github.io/2019/02/20/wangqing28/%E6%B5%85%E8%B0%88%E5%BD%93Swift%E4%B8%ADdefer%E5%92%8Cinout%E5%90%8C%E6%97%B6%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <id>http://xgfe.github.io/2019/02/20/wangqing28/浅谈当Swift中defer和inout同时起作用/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-05-05T10:21:43.549Z</updated>
    
    <content type="html"><![CDATA[<p>本文针对 <code>Swift</code> 中 <code>defer</code>、<code>inout</code> 以及 <code>return</code> 时相互影响的时候的情况进行简单的分析，目的是更好的理解 <code>defer</code>、<code>inout</code> 原理以及使用场合，减少踩坑和提高<code>debug</code>效率。</p><blockquote><p>本文中的示例代码，均为 <code>Swift 4.2</code> 版本</p></blockquote><a id="more"></a><h2 id="inout和defer"><a href="#inout和defer" class="headerlink" title="inout和defer"></a>inout和defer</h2><h3 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h3><p>有关 <code>inout</code> 关键字苹果官方描述</p><blockquote><p>If you want a function to modify a parameter’s value, and you want those changes to persist after the function call has ended, define that parameter as an in-out parameter instead.</p></blockquote><p>我们可以了解到，<code>inout</code> 关键字，有点类似于 <code>C</code> 语言中的引用传递或指针传递，目的是为了对入参进行修改。 但实际上 <code>inout</code> 的机制并不是引用传递，或者是指针传递。</p><p>以下是两段比较详细的苹果官方描述，摘出来看比较清晰：</p><blockquote><p>You write an in-out parameter by placing the inout keyword right before a parameter’s type. An in-out parameter has a value that is passed in to the function, is modified by the function, and is passed back out of the function to replace the original value. </p><p>in-out parameters are passed as follows:<br>When the function is called, the value of the argument is copied.<br>In the body of the function, the copy is modified.<br>When the function returns, the copy’s value is assigned to the original argument.<br>This behavior is known as copy-in copy-out or call by value result. </p></blockquote><p>从这两段我们可以看出，<code>inout</code> 的实现原理是：</p><ol><li>参数传入，拷贝一份 <strong>临时变量</strong></li><li>函数体中，修改的是这一份 <strong>临时变量</strong></li><li>函数返回时，这份 <strong>临时变量</strong> 被赋予给 <strong>原始参数</strong></li></ol><p>所以，是先拷贝，再修改，再拷贝回去的逻辑。这一点至关重要。</p><p>使用示例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">f(x: &amp;a)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">// 结果为 11</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于对象，即非 <code>Swift</code> 类型的，因为本身即为指针，所以本身就是指针传递，函数内部调用对象方法进行操作进而导致对象内部值的变化时，并不需要 <code>inout</code> 关键字。但是如果你想对这个对象变量整体进行的赋值替换操作，并且能反应到外部时，就需要 <code>inout</code>。<br>本文为了方便讨论，此处以及后续将仅仅以 <code>Swift</code> 原生类型作为例子。</p></blockquote><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>有关 <code>defer</code> 关键字苹果官方的描述</p><blockquote><p>A defer statement is used for executing code just before transferring program control outside of the scope that the defer statement appears in.</p><p>This means that a defer statement can be used, for example, to perform manual resource management such as closing file descriptors, and to perform actions that need to happen even if an error is thrown.</p></blockquote><p>简单说来， <code>defer</code> 是用来定义一段代码，用来在 <strong>离开</strong> 所在 <code>scope</code> 的时候执行。 苹果官方对 <code>defer</code> 的建议，也是用来关闭描述符、处理一些错误等等。</p><p>使用示例<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"do defer"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"do func"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"func done"</span>)</span><br><span class="line">&#125;</span><br><span class="line">g()</span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">do func</span></span><br><span class="line"><span class="comment">func done</span></span><br><span class="line"><span class="comment">do defer</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>这里注意一下， <code>defer</code> 的生效时机是 <code>scope</code> 离开的时候，而 <strong>不是函数执行完毕</strong> 的时候。 所以如果 <code>defer</code> 写在 <code>if</code> 或者 <code>for</code> 的内部， 会在 <code>if</code> 结束的时候立刻执行。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>因为很多写 <code>Swift</code> 的同学都是从 <code>Objective-C</code> 过来的，从使用习惯上来说，用 <code>inout</code> 会多一些， <code>defer</code> 并不太多。 但是当 <code>inout</code> 和 <code>defer</code> 以及 <code>return</code> 共同起作用的时候往往会有一些微妙的问题。</p><ol><li><code>defer</code> 本身是个 <code>block</code>，他内部也是可以修改变量。比如：<br><code>defer { x += 1 }</code></li><li><code>return</code> 的时候，也是可以执行一个 <code>block</code> 的。 比如 <code>return { x + 1 }()</code>，同时自身也会往栈上压入值</li><li><code>inout</code> 也是会改变入参的值。（再强调下，是复制-&gt;修改-&gt;写回，而不是原地修改）</li></ol><p>假如一个 <code>inout</code> 入参，在 <code>defer</code> 中被修改，在 <code>return</code> 的 <code>block</code> 中被修改。 那么问题来了：</p><ol><li>这几处修改的生效顺序是什么</li><li>对于 <code>inout</code> 和 <code>return</code> 而言，外界拿到的是什么时候的什么值</li></ol><p>用代码来举例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ret: <span class="subst">\( fdo(x: &amp;outX)</span> )"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"after-ret: <span class="subst">\( outX )</span>"</span>)</span><br></pre></td></tr></table></figure></p><p>问题：</p><ol><li>几处修改何时生效</li><li><code>fdo</code> 返回的值是多少</li><li>最后的 <code>outX</code> 值又是多少</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了能知道结果，对上述代码进行扩充<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">print</span><span class="params">(tag: String,  v:Int)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(tag)</span>:\t<span class="subst">\(v)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fdo</span><span class="params">(x: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-def"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-def"</span>, v: x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"st-fdo"</span>, v: x)</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(tag: <span class="string">"ed-fdo"</span>, v: x)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"st-ret"</span>, v: x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(tag: <span class="string">"ed-ret"</span>, v: x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> outX: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-before"</span>, v: outX)</span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"v-return"</span>, v: fdo(x: &amp;outX)) <span class="comment">// 如果代码改成 outX = fdo(x: &amp;outX)，下一行会如何？ 和现在会一样吗</span></span><br><span class="line"><span class="built_in">print</span>(tag: <span class="string">"x-after"</span>, v: outX)</span><br></pre></td></tr></table></figure></p><p>输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x-before:10</span><br><span class="line">st-fdo:10</span><br><span class="line">ed-fdo:11</span><br><span class="line">st-ret:11</span><br><span class="line">ed-ret:12</span><br><span class="line">st-def:12</span><br><span class="line">ed-def:13</span><br><span class="line">v-return:12</span><br><span class="line">x-after:13</span><br><span class="line">// 如果代码改动 outX = fdo(x: &amp;outX)</span><br><span class="line">// 结果将是  x-after:12</span><br></pre></td></tr></table></figure></p><p>几个关注点</p><ol><li>打印顺序</li><li>各个节点的值</li><li><code>Swift</code> 执行的是写时拷贝</li></ol><blockquote><p>除了打日志分析之外，也可以检查汇编代码。</p></blockquote><p>简单分析一下可知如下执行顺序：</p><ol><li>正常调用<ol><li>此时内部生成临时变量 <code>x&#39;</code>，后续均操作此 <code>x&#39;</code></li></ol></li><li><code>return</code> 中 <code>block</code> 执行</li><li><code>defer</code> 执行 （如果多个，按倒序）</li><li><code>return</code> 返回<ol><li>此时返回出来的是 <strong>临时变量</strong></li><li>只是返回，<strong>函数调用</strong> 所在的整个语句并未执行</li></ol></li><li><code>inout</code> 生效<ol><li>用内部生成 <code>x&#39;</code> 回填栈顶，即将入参的 <code>x</code> 替换成 <code>x&#39;</code>，调用方取回</li></ol></li><li><strong>函数调用</strong> 所在的代码行生效，使用 <code>return</code> 返回的值对外操作，如外赋值、打印等等</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从实际的实现角度来说，执行顺序是:<br><strong>return中代码</strong> -&gt; <code>defer</code> -&gt; <code>return</code> -&gt; <code>inout</code> -&gt; <strong>调用处代码</strong></p><p>从变量和内存的角度考虑</p><ol><li><code>Swift</code> 是写时拷贝</li><li><code>inout</code> 是创建临时变量 -&gt; 返回时用临时变量覆盖传入变量，而不是原地修改</li></ol><p>从实际使用来说</p><ol><li>对于 <code>defer</code> 使用，应遵循苹果的官方建议，主要用于关闭描述符、处理一些错误。虽然可以做一些额外的副作用，甚至可以根据执行的特性，来在 <code>return</code> 之后再影响外部的一些东东，但是不建议做这些操作。</li><li>对于 <code>inout</code> ，需要了解执行的机制，不能根据现象对机制有所误判。</li><li>建议尽量少用 <strong>副作用</strong> 来达成一些预期，如在函数中过多的对外部变量进行修改，尤其是值类型的变量。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://onevcat.com/2018/11/defer/" target="_blank" rel="noopener">关于 Swift defer 的正确使用</a></li><li><a href="https://docs.swift.org/swift-book/LanguageGuide/Functions.html" target="_blank" rel="noopener">Swift Language Guide</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Statements.html#grammar_defer-statement" target="_blank" rel="noopener">Swift Language Reference - Statements - defer</a></li><li><a href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID545" target="_blank" rel="noopener">Swift Language Reference - Declarations - In-Out Parameters</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文针对 &lt;code&gt;Swift&lt;/code&gt; 中 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 以及 &lt;code&gt;return&lt;/code&gt; 时相互影响的时候的情况进行简单的分析，目的是更好的理解 &lt;code&gt;defer&lt;/code&gt;、&lt;code&gt;inout&lt;/code&gt; 原理以及使用场合，减少踩坑和提高&lt;code&gt;debug&lt;/code&gt;效率。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文中的示例代码，均为 &lt;code&gt;Swift 4.2&lt;/code&gt; 版本&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="wangqing28" scheme="http://xgfe.github.io/categories/wangqing28/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="http://xgfe.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Angular CDK 部分功能介绍</title>
    <link href="http://xgfe.github.io/2019/01/17/luanmingyang/Angular%20CDK%20%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xgfe.github.io/2019/01/17/luanmingyang/Angular CDK 部分功能介绍/</id>
    <published>2019-01-17T11:31:00.000Z</published>
    <updated>2019-05-05T02:41:48.384Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。</p><a id="more"></a><h1 id="Angular-CDK-部分功能介绍"><a href="#Angular-CDK-部分功能介绍" class="headerlink" title="Angular CDK 部分功能介绍"></a>Angular CDK 部分功能介绍</h1><p>Angular CDK(Component Dev Kit) 是一个组件开发工具包，实现了一些公共的交互，同时不关注组件的具体呈现，可以在组件的开发中使用。</p><p>Angular CDK主要分为两大类：</p><ul><li><p>Common Behaviors</p><p>一组包括了常见功能需求的工具，只与组件行为相关，不影响组件的呈现。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/a11y" target="_blank" rel="noopener">Accessibility</a> 提供了许多改进可访问性的工具</li><li><a href="https://material.angular.io/cdk/bidi" target="_blank" rel="noopener">Bidirectionality</a> 用于获取和响应LTR / RTL布局方向的变化</li><li><a href="https://material.angular.io/cdk/drag-drop" target="_blank" rel="noopener">Drag and Drop</a> 提供了声明式创建拖拽的接口，支持自由拖拽、列表排序等</li><li><a href="https://material.angular.io/cdk/layout" target="_blank" rel="noopener">Layout</a> 用于构建响应屏幕大小改变的响应式UI</li><li><a href="https://material.angular.io/cdk/observers" target="_blank" rel="noopener">Observers</a> 提供了一组 observers 指令</li><li><a href="https://material.angular.io/cdk/overlay" target="_blank" rel="noopener">Overlay</a> 提供了一种在屏幕上打开浮动面板的方法</li><li><a href="https://material.angular.io/cdk/platform" target="_blank" rel="noopener">Platform</a> 用于收集当前平台及其支持的不同功能的信息</li><li><a href="https://material.angular.io/cdk/portal" target="_blank" rel="noopener">Portal</a> 用于将动态内容呈现到应用程序</li><li><a href="https://material.angular.io/cdk/scrolling" target="_blank" rel="noopener">Scrolling</a> 提供了对滚动的处理</li><li><a href="https://material.angular.io/cdk/text-field" target="_blank" rel="noopener">Text field</a> 用于处理文本输入</li></ul></li><li><p>Components</p><p>一组具有实用功能的无样式组件。</p><p>目前主要包括：</p><ul><li><a href="https://material.angular.io/cdk/stepper" target="_blank" rel="noopener">Stepper</a> 步进器</li><li><a href="https://material.angular.io/cdk/table" target="_blank" rel="noopener">Table</a> 可自定义的 data-table</li><li><a href="https://material.angular.io/cdk/tree" target="_blank" rel="noopener">Tree</a> 方便为结构化数据构建树型结构</li></ul></li></ul><p>本文主要包括了三部分的介绍：Portal、Overlay、a11y/FocusTrap</p><h2 id="1-Angular-CDK-之-Portal"><a href="#1-Angular-CDK-之-Portal" class="headerlink" title="1. Angular CDK 之 Portal"></a>1. Angular CDK 之 Portal</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Portal 用于将动态内容呈现到应用程序。</p><p>Portal：动态内容，可以是 <code>Component</code> 或 <code>TemplateRef</code></p><p>PortalOutlet：放置动态内容的地方</p><p><a href="https://material.angular.io/cdk/portal/api#DomPortalOutlet" target="_blank" rel="noopener">Portal API</a></p><h3 id="1-2-指令"><a href="#1-2-指令" class="headerlink" title="1.2 指令"></a>1.2 指令</h3><h4 id="CdkPortal"><a href="#CdkPortal" class="headerlink" title="CdkPortal"></a>CdkPortal</h4><p>指令版本 <code>TemplatePortal</code>，用于从 <code>&lt;ng-template&gt;</code> 获取一个Portal。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件内部可以使用 <code>@ViewChild</code> 或 <code>@ViewChildren</code> 获取引用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ViewChildren</span>(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br></pre></td></tr></table></figure><p><img src="/Users/luanmingyang/Desktop/luan/img/portal-cdkportal.png" width="540"></p><h4 id="CdkPortalOutlet"><a href="#CdkPortalOutlet" class="headerlink" title="CdkPortalOutlet"></a>CdkPortalOutlet</h4><p>用于添加 <code>PortalOutlet</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="🌰-动态切换内容"><a href="#🌰-动态切换内容" class="headerlink" title="🌰 动态切换内容"></a>🌰 动态切换内容</h4><p><a href="https://stackblitz.com/edit/angular-hua49e?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用时需要先引入对应模块：</p><p><code>import {PortalModule} from &#39;@angular/cdk/portal&#39;;</code></p><p>首先设置一个插槽，用于放置动态内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> [<span class="attr">cdkPortalOutlet</span>]=<span class="string">"curPortal"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要动态显示的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> <span class="attr">cdkPortal</span>&gt;</span>Portal1<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> *<span class="attr">cdkPortal</span>&gt;</span>Portal2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ng-template</span> #<span class="attr">template</span>&gt;</span>Portal3<span class="tag">&lt;/<span class="name">ng-template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过改变 <code>curPortal</code> 切换显示内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">PortalDemoComponent</span> </span>&#123;</span><br><span class="line">  curPortal: Portal&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 获取动态内容引用</span></span><br><span class="line">  @ViewChildren(CdkPortal) templatPortals: QueryList&lt;CdkPortal&gt;;</span><br><span class="line">  @ViewChild(<span class="string">'template'</span>) template: TemplateRef&lt;any&gt;;</span><br><span class="line">  <span class="comment">// 切换</span></span><br><span class="line">  changePortal() &#123;</span><br><span class="line">    <span class="comment">// this.curPortal = xxx;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-常用class"><a href="#1-3-常用class" class="headerlink" title="1.3 常用class"></a>1.3 常用class</h3><h4 id="Portal"><a href="#Portal" class="headerlink" title="Portal"></a>Portal</h4><p>想要渲染在其它位置的内容，可以附加到 <code>PortalOutlet</code>，或从 <code>PortalOutlet</code> 分离。</p><p>可以通过 <code>isAttached</code> 属性判断是否已经被附加到某个 <code>PortalOutlet</code>。</p><h4 id="ComponentPortal"><a href="#ComponentPortal" class="headerlink" title="ComponentPortal"></a>ComponentPortal</h4><p>可以在attach时实例化某些组件</p><p><code>new ComponentPortal&lt;{}&gt;(component: ComponentType&lt;{}&gt;, viewContainerRef?: ViewContainerRef, injector?: Injector, componentFactoryResolver?: ComponentFactoryResolver): ComponentPortal&lt;{}&gt;</code></p><h4 id="TemplatePortal"><a href="#TemplatePortal" class="headerlink" title="TemplatePortal"></a>TemplatePortal</h4><p>表示一些嵌入的模版</p><p><code>new TemplatePortal&lt;{}&gt;(template: TemplateRef&lt;{}&gt;, viewContainerRef: ViewContainerRef, context?: {}): TemplatePortal&lt;{}&gt;</code></p><h4 id="DomPortalOutlet"><a href="#DomPortalOutlet" class="headerlink" title="DomPortalOutlet"></a>DomPortalOutlet</h4><p>用于将 Portal 附加到Angular应用程序上下文之外的任意DOM元素，也就是附加到 <code>&lt;app-root&gt;</code> 之外</p><h5 id="🌰-简单使用示例"><a href="#🌰-简单使用示例" class="headerlink" title="🌰 简单使用示例"></a>🌰 简单使用示例</h5><p><a href="https://stackblitz.com/edit/angular-dxl7fg?file=src%2Fapp%2Fportal%2Fportal-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">domPortalOutlet: DomPortalOutlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>(</span><br><span class="line">    private viewContainerRef: ViewContainerRef,</span><br><span class="line">    private injector: Injector,</span><br><span class="line">    private componentFactoryResolver: ComponentFactoryResolver,</span><br><span class="line">    private appRef: ApplicationRef) &#123;&#125;</span><br><span class="line"></span><br><span class="line">createOutletOutApp() &#123;</span><br><span class="line">  <span class="keyword">const</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  elem.innerHTML = <span class="string">'&amp;ltapp-root&amp;gt;外的插槽'</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(elem);</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet = <span class="keyword">new</span> DomPortalOutlet(elem, <span class="keyword">this</span>.componentFactoryResolver, <span class="keyword">this</span>.appRef, <span class="keyword">this</span>.injector);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attachTemplatePortal() &#123;</span><br><span class="line">  <span class="keyword">this</span>.domPortalOutlet.attachTemplatePortal(<span class="keyword">this</span>.templatPortals.first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>new DomPortalOutlet(elem, this.componentFactoryResolver, this.appRef, this.injector);</code> 把elem 变成Angular可管理的插槽。</p><p><img width="360" src="/Users/luanmingyang/Desktop/luan/img/portal-DomPortalOutlet.png"></p><h5 id="DomPortalOutlet-在-Angular-Material-中的使用"><a href="#DomPortalOutlet-在-Angular-Material-中的使用" class="headerlink" title="DomPortalOutlet 在 Angular Material 中的使用"></a>DomPortalOutlet 在 Angular Material 中的使用</h5><p>在 Angular Material CDK Overlay 中，通过使用 DomPortalOutlet 在 <code>&lt;app-root&gt;</code> 之外创建 Overlay container</p><p><a href="https://github.com/angular/material2/blob/master/src/cdk/overlay/overlay.ts#L117" target="_blank" rel="noopener">源码</a> 部分代码实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pane = <span class="keyword">this</span>._createPaneElement(host);</span><br><span class="line"><span class="keyword">const</span> portalOutlet = <span class="keyword">this</span>._createPortalOutlet(pane);</span><br><span class="line"></span><br><span class="line">private _createPaneElement(host: HTMLElement): HTMLElement &#123;</span><br><span class="line">    <span class="keyword">const</span> pane = <span class="keyword">this</span>._document.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">    pane.id = <span class="string">`cdk-overlay-<span class="subst">$&#123;nextUniqueId++&#125;</span>`</span>;</span><br><span class="line">    pane.classList.add(<span class="string">'cdk-overlay-pane'</span>);</span><br><span class="line">    host.appendChild(pane);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private _createPortalOutlet(pane: HTMLElement): DomPortalOutlet &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._appRef) &#123;</span><br><span class="line">      <span class="keyword">this</span>._appRef = <span class="keyword">this</span>._injector.get&lt;ApplicationRef&gt;(ApplicationRef);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DomPortalOutlet(pane, <span class="keyword">this</span>._componentFactoryResolver, <span class="keyword">this</span>._appRef, <span class="keyword">this</span>._injector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Angular-CDK-之-Overlay"><a href="#2-Angular-CDK-之-Overlay" class="headerlink" title="2. Angular CDK 之 Overlay"></a>2. Angular CDK 之 Overlay</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Overlay 提供了一种在屏幕上打开浮动面板的方法，即在 <code>&lt;app-root&gt;</code> 之外创建叠加层，并且该叠加层仍在 Angular 控制范围内。</p><p>主要用于构建公共组件，Modal、Tooltip、Menu、Select等组件的构建过程中都可以选择使用 Overlay。</p><p>使用时需要先引入对应模块：</p><p><code>import {OverlayModule} from &#39;@angular/cdk/overlay&#39;;</code></p><p>通过调用 <code>overlay.create()</code> 创建一个 <code>OverlayRef</code> 实例，<code>OverlayRef</code> 是一个 <code>PortalOutlet</code>，一旦被创建，可以通过附加 <code>Portal</code> 为其添加内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> overlayRef = overlay.create();</span><br><span class="line"><span class="keyword">const</span> userProfilePortal = <span class="keyword">new</span> ComponentPortal(UserProfile);</span><br><span class="line">overlayRef.attach(userProfilePortal);</span><br></pre></td></tr></table></figure><p>创建时 <code>OverlayRef</code> 时可以提供可选的配置对象 <code>OverlayConfig</code>。</p><p><a href="https://material.angular.io/cdk/overlay/api#Overlay" target="_blank" rel="noopener">Overlay API</a></p><h3 id="2-2-OverlayRef"><a href="#2-2-OverlayRef" class="headerlink" title="2.2 OverlayRef"></a>2.2 OverlayRef</h3><p>使用服务创建的Overlay引用，用于对其操纵或处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverlayDemoComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  overlayRef: OverlayRef;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(private overlay: Overlay) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit(): <span class="keyword">void</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-create.png"></p><h3 id="2-3-OverlayConfig"><a href="#2-3-OverlayConfig" class="headerlink" title="2.3 OverlayConfig"></a>2.3 OverlayConfig</h3><p>创建Overlay时使用的配置对象。</p><p>属性：</p><ul><li>hasBackdrop：是否使用遮罩</li><li>backdropClass：遮罩的classname，使得我们可以自定义遮罩的样式</li><li>positionStrategy：PositionStrategy 指定位置策略</li><li>scrollStrategy：ScrollStrategy 指定在打开时处理滚动事件的策略</li><li>direction：文本的方向</li><li>panelClass：指定 Overlay 类名</li><li>disposeOnNavigation：当用户在前进/后退时是否应该丢弃。注意，通常不包括单击链接（除非在使用<code>HashLocationStrategy</code>）。</li><li>width/minWidth/maxWidth：定义宽度。类型为number时，则默认单位为px</li><li>height/minHeight/maxHeight：定义高度。类型为number时，则默认单位为px</li></ul><p>可以通过 OverlayRef 指定 backdrop 的点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-4-两种位置策略"><a href="#2-4-两种位置策略" class="headerlink" title="2.4 两种位置策略"></a>2.4 两种位置策略</h3><ul><li><p>GlobalPositionStrategy</p><p>使用此策略，叠加层被赋予相对于浏览器视口的显式位置，与其他元素无关。</p></li><li><p>ConnectedPositionStrategy（弃用）</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li><li><p>FlexibleConnectedPositionStrategy</p><p>使用此策略，叠加层被赋予相对于某个元素的隐式位置。相对位置是根据Overlay上的点相对原点定义的。例如，下拉列表将原点的左下角连接到叠加层的左上角。</p></li></ul><h3 id="2-5-四种滚动策略"><a href="#2-5-四种滚动策略" class="headerlink" title="2.5 四种滚动策略"></a>2.5 四种滚动策略</h3><ul><li><p>NoopScrollStrategy</p><p>默认，什么都不做。</p></li><li><p>CloseScrollStrategy</p><p>滚动时会自动关闭叠加层。</p></li><li><p>BlockScrollStrategy</p><p>将在打开时阻止页面滚动。</p></li><li><p>RepositionScrollStrategy</p><p>滚动时会重新定位覆盖元素，会对滚动产生一些性能影响。</p></li></ul><h3 id="🌰-示例"><a href="#🌰-示例" class="headerlink" title="🌰 示例"></a>🌰 示例</h3><p><a href="https://stackblitz.com/edit/angular-zmcuh9?file=src%2Fapp%2Foverlay%2Foverlay-demo.component.ts" target="_blank" rel="noopener">传送门</a></p><p>使用 Overlay 需要先引入必要的样式</p><p><code>@import &#39;~@angular/cdk/overlay-prebuilt.css&#39;;</code></p><h4 id="1-创建菜单"><a href="#1-创建菜单" class="headerlink" title="1. 创建菜单"></a>1. 创建菜单</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createMenu() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position()</span><br><span class="line">    .flexibleConnectedTo(<span class="keyword">this</span>.createMenuBtn).withPositions([&#123;</span><br><span class="line">      originX: <span class="string">'center'</span>,</span><br><span class="line">      originY: <span class="string">'bottom'</span>,</span><br><span class="line">      overlayX: <span class="string">'center'</span>,</span><br><span class="line">      overlayY: <span class="string">'top'</span></span><br><span class="line">    &#125;]);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(&#123;</span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.menuTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>overlay.position()</code> 方法获取一个 <code>OverlayPositionBuilder</code> ，通过它来配置位置策略。</p><p>通过调用 <code>flexibleConnectedTo(elementRef)</code> 方法创建位置策略 <code>FlexibleConnectedPositionStrategy</code></p><p><img width="100" src="/Users/luanmingyang/Desktop/luan/img/overlay-menu.png"></p><h4 id="2-创建弹出框"><a href="#2-创建弹出框" class="headerlink" title="2. 创建弹出框"></a>2. 创建弹出框</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">createDialog() &#123;</span><br><span class="line">  <span class="keyword">const</span> strategy = <span class="keyword">this</span>.overlay.position().global().centerHorizontally().centerVertically();</span><br><span class="line">  <span class="keyword">const</span> config = <span class="keyword">new</span> OverlayConfig(&#123;</span><br><span class="line">    hasBackdrop: <span class="literal">true</span>, <span class="comment">// 使用backdrop</span></span><br><span class="line">    positionStrategy: strategy</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef = <span class="keyword">this</span>.overlay.create(config);</span><br><span class="line">  <span class="keyword">this</span>.overlayRef.attach(<span class="keyword">new</span> TemplatePortal(<span class="keyword">this</span>.dialogTpl, <span class="keyword">this</span>.viewContainerRef));</span><br><span class="line">  <span class="comment">// 绑定backdrop点击事件</span></span><br><span class="line">  <span class="keyword">this</span>.overlayRef.backdropClick().subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.overlayRef.detach();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用 <code>global()</code> 方法创建位置策略 <code>GlobalPositionStrategy</code></p><p><img width="400" src="/Users/luanmingyang/Desktop/luan/img/overlay-dialog.png"></p><h2 id="3-Angular-CDK-之-a11y"><a href="#3-Angular-CDK-之-a11y" class="headerlink" title="3. Angular CDK 之 a11y"></a>3. Angular CDK 之 a11y</h2><h3 id="3-1-a11y-概述"><a href="#3-1-a11y-概述" class="headerlink" title="3.1 a11y 概述"></a>3.1 a11y 概述</h3><p>a11y 提供了许多改进可访问性的工具。</p><p>使用时需要先引入对应模块：</p><p><code>import {A11yModule} from &#39;@angular/cdk/a11y&#39;;</code></p><h3 id="3-2-FocusTrap"><a href="#3-2-FocusTrap" class="headerlink" title="3.2 FocusTrap"></a>3.2 FocusTrap</h3><p>旨在用于为对话框等<strong>焦点必须受到约束</strong>的组件创建可访问的体验。</p><h4 id="3-2-1-指令"><a href="#3-2-1-指令" class="headerlink" title="3.2.1 指令"></a>3.2.1 指令</h4><p><code>cdkTrapFocus</code> 在区域内捕获焦点的指令。</p><p>可以显式地声明聚焦的区域：</p><p><code>cdkFocusInitial</code> 指定在初始化区域时将获得焦点的元素。</p><p><code>cdkFocusRegionStart</code> 与 <code>cdkFocusRegionEnd</code> 定义焦点将被捕获的区域。使用Tab键时，焦点将在此区域中移动并在两端环绕。</p><h4 id="3-2-2-FocusTrapFactory"><a href="#3-2-2-FocusTrapFactory" class="headerlink" title="3.2.2 FocusTrapFactory"></a>3.2.2 FocusTrapFactory</h4><p>用于根据给定的元素创建一个焦点捕获区域。</p><p><code>focusTrap = focusTrapFactory.create(element);</code></p><h4 id="3-2-3-FocusTrap"><a href="#3-2-3-FocusTrap" class="headerlink" title="3.2.3 FocusTrap"></a>3.2.3 FocusTrap</h4><p>允许在DOM元素中捕获焦点的类。</p><p>它假定Tab键顺序与DOM顺序相同，但实际上这是不一定的，如 tabIndex &gt; 0 或 指定了 flex order 等情况。</p><ul><li>focusFirstTabbableElement()   聚焦区域内的第一个可捕捉元素</li><li>focusFirstTabbableElementWhenReady()</li><li>focusInitialElement()  </li><li>focusInitialElementWhenReady()</li><li>focusLastTabbableElement()</li><li>focusLastTabbableElementWhenReady()</li></ul><h4 id="3-2-4-实际中的使用"><a href="#3-2-4-实际中的使用" class="headerlink" title="3.2.4 实际中的使用"></a>3.2.4 实际中的使用</h4><p>以公共组件 Dialog 为例，需要在 Dialog 打开时，将焦点约束在 Dialog 区域内部。</p><p>主要分为三步：</p><ol><li>打开 Dialog 时，保存当前获得焦点的元素</li><li>使 Dialog 获得焦点，并将焦点约束在 Dialog 内</li><li>Dialog 关闭时，将焦点恢复到之前聚焦的元素上</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component, Inject &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FocusTrap, FocusTrapFactory &#125; <span class="keyword">from</span> <span class="string">'@angular/cdk/a11y'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DOCUMENT &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialog</span> </span>&#123;</span><br><span class="line">    focusTrap: FocusTrap;</span><br><span class="line">    prevFocusedElem: HTMLElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(</span><br><span class="line">        private elementRef: ElementRef,</span><br><span class="line">        private focusTrapFactory: FocusTrapFactory,</span><br><span class="line">        @Inject(DOCUMENT) private document: any) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 Dialog open 之前聚焦的元素</span></span><br><span class="line">    savePrevFocusedElement() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.document) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem = <span class="keyword">this</span>.document.activeElement <span class="keyword">as</span> HTMLElement;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.elementRef.nativeElement.focus) &#123;</span><br><span class="line">                <span class="comment">// 元素可能无法立即聚焦</span></span><br><span class="line">                <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.elementRef.nativeElement.focus();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将焦点限制在 Dialog 内部</span></span><br><span class="line">    trapFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="keyword">this</span>.focusTrapFactory.create(<span class="keyword">this</span>.elementRef.nativeElement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.focusTrap.focusInitialElementWhenReady();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dialog close 时恢复原来聚焦的元素</span></span><br><span class="line">    restoreFocus() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.prevFocusedElem &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>.prevFocusedElem.focus === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.prevFocusedElem.focus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.focusTrap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.focusTrap.destroy();</span><br><span class="line">            <span class="keyword">this</span>.focusTrap = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Angular CDK 的部分功能，主要包括了三部分：Portal、Overlay、a11y/FocusTrap。&lt;/p&gt;
    
    </summary>
    
      <category term="luanmingyang" scheme="http://xgfe.github.io/categories/luanmingyang/"/>
    
    
      <category term="Angular" scheme="http://xgfe.github.io/tags/Angular/"/>
    
      <category term="Angular CDK" scheme="http://xgfe.github.io/tags/Angular-CDK/"/>
    
  </entry>
  
  <entry>
    <title>mysql通信协议浅解</title>
    <link href="http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/"/>
    <id>http://xgfe.github.io/2018/12/21/rongweiwei/mysql-protocol/</id>
    <published>2018-12-20T16:00:00.000Z</published>
    <updated>2019-05-05T11:28:18.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。</p><p>代码部分经过nodejs的mysql模块和php的mysqli模块验证。</p><p>此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。</p><a id="more"></a><hr><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>mysql链接分为TCP握手链接，服务端对客户端认证，数据交互，断开链接几个阶段。<br>服务器启动后，会使用 TCP 监听一个本地端口，当客户端的连接请求到达时，就会执行三段握手以及 MySQL 的权限验证；验证成功后，客户端开始发送请求，服务器会以响应的报文格式返回数据；当客户端发送完成后，会发送一个特殊的报文，告知服务器已结束会话。</p><p>MySQL 定义了几种包类型，A) 客户端-&gt;服务器，登录时的 auth 包、执行 SQL 时的 CMD 包；B) 服务器-&gt;客户端，登录时的握手包、数据包、数据流结束包、成功包(OK Packet)、错误信息包。</p><p>协议定义了基本的数据类型，如 int、string 等；数据的传送格式等。</p><h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则"></a>一些规则</h3><p>当server端和client端数据交互时，如果数据包size大于2^24时，要将包拆成多个；<br>每个包由header和payload两部分组成；</p><h3 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h3><pre><code>服务端 -&gt; 客户端：发送握手初始化包 (Handshake Initialization Packet)。客户端 -&gt; 服务端：发送验证包 (Client Authentication Packet)。服务端 -&gt; 客户端：认证结果消息</code></pre><p>mysql的认证过程相对复杂，这里简单介绍4.1版本之后的认证过程（计划功能中对这部分请求可以透明透给远程mysql，没有必要进行处理，以下内容摘自网络）。</p><ol><li><p>服务器发送随机字符串 (scramble) 给客户端。</p></li><li><p>客户端作如下计算，然后客户端将 token 发送给服务端。</p><blockquote><p>stage1_hash = SHA1(明文密码)</p><p>token = SHA1(scramble + SHA1(stage1_hash)) XOR stage1_hash</p></blockquote></li><li><p>服务端作如下计算，比对 SHA1(stage1_hash) 和 mysql.user.password 是否相同</p><blockquote><p>stage1_hash = token XOR SHA1(scramble + mysql.user.password)<br>server -&gt; client， client-&gt; server 包类型</p></blockquote><p> 校验时，只需要 SHA1(stage1_hash) 与 mysql.user.password 比较一下即可</p></li></ol><p>handshake包(protocol41)</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>protocol_version</td></tr><tr><td>n</td><td>(Null-Terminated String)   server_version</td></tr><tr><td>4</td><td>thread_id</td></tr><tr><td>8</td><td>scramble_buff</td></tr><tr><td>1</td><td>(filler) always 0x00</td></tr><tr><td>2</td><td>server_capabilities</td></tr><tr><td>1</td><td>server_language</td></tr><tr><td>2</td><td>server_status</td></tr><tr><td>13</td><td>(filler) always 0x00 …</td></tr><tr><td>13</td><td>rest of scramble_buff (4.1)</td></tr></tbody></table><h3 id="获得use-db"><a href="#获得use-db" class="headerlink" title="获得use db"></a>获得use db</h3><p> 对本次需求只需要取出初始化mysql链接的时候会初始化使用哪个库(use database;),需要从包里解出，其它部分忽略。</p><pre><code>function parseHandShake(buff){    let _check_pos = buff.indexOf(Buffer.alloc(23,0x00));    if (_check_pos &gt; 0){        //protocol41        buff =  buff.slice(_check_pos + 23);        protocol41 = true;    }    //find user field end    _check_pos = buff.indexOf(0x00);    buff =  buff.slice(_check_pos + 1);    if (protocol41) {        buff =  buff.slice(21);         } else {        buff =  buff.slice(10);         }    _check_pos = buff.indexOf(0x00);    let default_db = buff.slice(0, _check_pos).toString(); }</code></pre><hr><h2 id="query请求-封包"><a href="#query请求-封包" class="headerlink" title="query请求 封包"></a>query请求 封包</h2><p>client到server的包（Command Packet ），由两部分构成：header 和 payload。header包括3位整数表示payload长度，1位整数表示顺序号；payload包括1位COM标识符和请求sql语句</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<3></3></td><td>payload_length</td><td>payload的长度</td></tr><tr><td>int<1></1></td><td>sequence_id</td><td>顺序号，每次从0开始</td></tr><tr><td>string<var></var></td><td>payload</td><td>COM + sql ，COM_QUERY 标识符为0x03</td></tr></tbody></table><p>Example:</p><table><thead><tr><th>header</th><th>sequence</th><th>Description</th></tr></thead><tbody><tr><td>01 00 00</td><td>00</td><td>03 xx xx…</td></tr><tr><td>length 1</td><td>sequence_id 0</td><td>payload [0x03,Buffer from sql string …]</td></tr></tbody></table><p>部分代码</p><pre><code> var MAX_PACKET_LENGTH = Math.pow(2, 24) - 1; var buffer = Buffer.from(sql); for (var packet = 0; packet &lt; packets; packet++) {        var isLast = (packet + 1 === packets);    var packetLength = (isLast)           ? length % MAX_PACKET_LENGTH           : MAX_PACKET_LENGTH;       var packetNumber = incrementPacketNumber();       this.writeUnsignedNumber(3, packetLength);       this.writeUnsignedNumber(1, packetNumber);       var start = packet * MAX_PACKET_LENGTH;       var end   = start + packetLength;       this.writeBuffer(buffer.slice(start, end));}</code></pre><p>writeUnsignedNumber用来把包长度和序号写入packet header</p><pre><code>function writeUnsignedNumber(bytes, value) {       for (var i = 0; i &lt; bytes; i++) {       this._buffer[this._offset++] = (value &gt;&gt; (i * 8)) &amp; 0xff       }}</code></pre><p>当header的长度小于MAX_PACKET_LENGTH时表示包传输完成，极端情况下会多传个空包过去（正好整分）。</p><p>通常sql不长的情况下，只需要一个包就可以。</p><pre><code>ComQueryPacket.prototype.write = function write(){    let _sql_buff = Buffer.from(this.sql),        _cmd_len = Buffer.byteLength(this.sql),        _buff = Buffer.alloc(_cmd_len + 1 + 3 + 1);        _sql_buff.copy(_buff , 5);    this._buffer = _buff;    this.writeUnsignedNumber(4, _cmd_len+1);    this.writeUnsignedNumber(1, this.command);    return this._buffer; }</code></pre><hr><h2 id="query返回-解包"><a href="#query返回-解包" class="headerlink" title="query返回 解包"></a>query返回 解包</h2><p>从服务器发往客户端的数据包有四种：成功报告包以及错误消息包，数据结束包、数据包。</p><ul><li>0x00: Packets.OkPacket</li><li>0xff: Packets.ErrorPacket</li><li>0xfe: Packets.EofPacket</li><li>其它</li></ul><h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><pre><code>let first = data.readUInt8(4)，    //探测包类型    last = data.readUInt8(Buffer.byteLength(data) -1); //用来检测字符串类型数据是否传输完成if (first === 0xff) {    //查询错误} else if (first === 0x00) {    //查询OK，这里可以解析握手包等} else {    //数据包    //NullTerminatedString（Null结尾方式）: 字符串以遇到Null作为结束标志，相应的字节为00    if (last === 0x00 ){         //检查数据包中列信息和数据信息是否都接收完成    }}</code></pre><h3 id="OK-Packet"><a href="#OK-Packet" class="headerlink" title="OK Packet"></a>OK Packet</h3><p>Payload</p><table><thead><tr><th>相对包内容的位置</th><th>长度（字节）</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>包头标识</td><td>0x00 代表这是一个OK 包</td></tr><tr><td>1</td><td>rows_len</td><td>影响行数</td><td>相应操作影响的行数，比如一个Update操作的记录是5条，那么这个值就为5</td></tr><tr><td>1 + rows_len</td><td>id_len</td><td>自增id</td><td>插入一条记录时，如果是自增id的话，返回的id值</td></tr><tr><td>1 + rows_len + id_len</td><td>2</td><td>服务器状态</td><td>用于表示服务器状态，比如是否是事务模式或者自动提交模式</td></tr><tr><td>3 + rows_len + id_len</td><td>2</td><td>警告数</td><td>上次命令引起的警告数</td></tr><tr><td>5 + rows_len + id_len</td><td>msg_len</td><td>额外信息</td><td>此次操作的一些额外信息</td></tr></tbody></table><h3 id="Error-Packet"><a href="#Error-Packet" class="headerlink" title="Error Packet"></a>Error Packet</h3><p>Payload</p><table><thead><tr><th>Type</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>int<1> [ff]</1></td><td>header</td><td>header of the ERR packet</td></tr><tr><td>int<2></2></td><td>error_code</td><td>错误码</td></tr><tr><td>if capabilities &amp; CLIENT_PROTOCOL_41 {</td></tr><tr><td>string[1]</td><td>sql_state_marker</td><td># marker of the SQL State</td></tr><tr><td>string[5]</td><td>sql_state</td><td>SQL State</td></tr><tr><td>} </td></tr><tr><td>string<eof></eof></td><td>error_message</td><td>报错信息</td></tr></tbody></table><h3 id="Result-Set-Packet"><a href="#Result-Set-Packet" class="headerlink" title="Result Set Packet"></a>Result Set Packet</h3><p>Result Set包产生于我们每次数据库执行需要返回结果集的时候，Server端发送给我们的包，比如平常的SELECT,SHOW等命令，Result Set包相对比较复杂，查询结果的完整内容由：<br>列数量信息 + 列包 + EOF包 + 行包 + EOF包，这五部分组成。</p><table><thead><tr><th>内容</th><th>含义</th></tr></thead><tbody><tr><td>Result Set Header</td><td>返回数据的字段(列)数量</td></tr><tr><td>Field</td><td>返回数据的列信息（多个）</td></tr><tr><td>EOF</td><td>列结束</td></tr><tr><td>Row Data</td><td>行数据（多个）</td></tr><tr><td>EOF</td><td>数据结束</td></tr></tbody></table><p>例子 SELECT @@version_comment查询的返回结果：</p><pre><code>01 00 00 01 01|27 00 00    02 03 64 65 66 00 00 00    .....&apos;....def...11 40 40 76 65 72 73 69    6f 6e 5f 63 6f 6d 6d 65    .@@version_comme6e 74 00 0c 08 00 1c 00    00 00 fd 00 00 1f 00 00|   nt..............05 00 00 03 fe 00 00 02    00|1d 00 00 04 1c 4d 79    ..............My53 51 4c 20 43 6f 6d 6d    75 6e 69 74 79 20 53 65    SQL Community Se72 76 65 72 20 28 47 50    4c 29|05 00 00 05 fe 00    rver (GPL)......00 02 00                                              ...</code></pre><p>VERSION 4.0</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>4 (Length Coded Binary)</td><td>length</td></tr><tr><td>2 (Length Coded Binary)</td><td>type</td></tr><tr><td>2 (Length Coded Binary)</td><td>flags</td></tr><tr><td>1</td><td>decimals</td></tr><tr><td>n (Length Coded Binary)</td><td>default</td></tr></tbody></table><p>VERSION 4.1</p><table><thead><tr><th>Bytes</th><th>Name</th></tr></thead><tbody><tr><td>n (Length Coded String)</td><td>catalog</td></tr><tr><td>n (Length Coded String)</td><td>db</td></tr><tr><td>n (Length Coded String)</td><td>table</td></tr><tr><td>n (Length Coded String)</td><td>org_table 原表名</td></tr><tr><td>n (Length Coded String)</td><td>name</td></tr><tr><td>n (Length Coded String)</td><td>org_name 原字段名</td></tr><tr><td>(filler)            0c</td><td></td></tr><tr><td>charsetnr           08 00</td><td></td></tr><tr><td>n (Length Coded String)</td><td>length</td></tr><tr><td>n (Length Coded String)</td><td>type</td></tr><tr><td>n (Length Coded String)</td><td>flags</td></tr><tr><td>n (Length Coded String)</td><td>decimals</td></tr><tr><td>(filler) 00 00</td></tr></tbody></table><p> 处理代码：</p><pre><code>/** 解析字段信息* @param Buffer * @result Object */function parseColDef(buff){    let _stack = _parseLine(buff);    if (_stack.length &lt; 2) return false;    if (!_stack) return false;    if (_stack[0] === &apos;def&apos;){        //protocol41        return {            &apos;db&apos; : _stack[1],            &apos;table&apos; : _stack[2],            &apos;table_full&apos; : _stack[3],            &apos;field&apos; : _stack[4],            &apos;field_full&apos; : _stack[5]        };        }else{        return {            &apos;table&apos; : _stack[0],            &apos;field&apos; : _stack[1],        };    }}/** 解析行数据* @param Buffer * @result Array */function parseColVal(buff){    let _stack = _parseLine(buff);    return _stack;}function _parseLine(buff){    let _stack = [];    for(let i=0,j=buff.length ; i &lt; j ; i++){        let _len = buff[i].toString() * 1;        let _content = buff.slice(i+1, i+ 1 + _len  );        _stack.push(_content.toString());        i += _len;      }    return _stack;}function Parser(options) {    options = options || {};    this.reset(options);}Parser.prototype.reset = function(options){    this._header = [];    this._body = [];    this._parsed_columns = [];    this._parsed_col_vals = [];    this.header_len = 4;    this._head_set = false;    this._body_set = false;    this._reset();}Parser.prototype._reset = function(){    this._buffer = Buffer.alloc(0);    this._offset = 0;}//将字段部分和数据部分分开存放Parser.prototype._put = function(chunk){    if (0 === chunk.length) return;    if (this._head_set){        this._body.push(chunk);    }else{        this._header.push(chunk);    }}//获得result packetParser.prototype.write = function(chunk ,to_parse){    if (this._body_set) return false;    this._buffer = Buffer.concat([this._buffer,chunk]);    this._offset = 0;    this._process(to_parse);}Parser.prototype._process = function(to_parse){    let _header_len = this.header_len;    while(true){        if (this._buffer.length === 0 ){            break;        }        let _len = this.parseUnsignedNumber(3),            _number = this.parseUnsignedNumber(1);        if ((_len + _header_len) &gt; this._buffer.length){            break;        }        let _piece = this._buffer.slice(0,_len + _header_len),             _first = _piece.readUInt8(4);        this._put(_piece);        if (0xfe === _first){            if (!this._head_set){                this._head_set = true;                    this._parsed_col_vals = [];                for (let _m = 0,_n = this._parsed_columns.length; _m &lt; _n ; _m++){                    this._parsed_col_vals.push([]);                }            }else{                this._body_set = true;            }        } else if(to_parse){            if (!this._head_set){                let _column = parseColDef(_piece.slice(_header_len));                if (_column){                    this._parsed_columns.push(_column.field);                }            }else{                let _col_val = parseColVal(_piece.slice(_header_len));                for(let _m=0,_n=_col_val.length; _m &lt; _n;_m++){                    this._parsed_col_vals[_m].push(_col_val[_m]);                    }             }        }        this._buffer = this._buffer.slice(_piece.length );        this._offset = 0;    }}//读取解析后数据Parser.prototype.read = function(){    return {        head : this._header,        body : this._body,        headed : this._head_set,        bodyed : this._body_set,        columns : this._parsed_columns,        columns_vals : this._parsed_col_vals    }}//写入数字类型信息Parser.prototype.parseUnsignedNumber = function parseUnsignedNumber(bytes) {    if (bytes === 1) {        return this._buffer[this._offset++];    }    var buffer = this._buffer;    var offset = this._offset + bytes - 1;    var value  = 0;    if (bytes &gt; 4) {        var err    = new Error(&apos;parseUnsignedNumber: Supports only up to 4 bytes&apos;);        err.offset = (this._offset - this._packetOffset - 1);        err.code   = &apos;PARSER_UNSIGNED_TOO_LONG&apos;;        throw err;    }    while (offset &gt;= this._offset) {        value = ((value &lt;&lt; 8) | buffer[offset]) &gt;&gt;&gt; 0;        offset--;    }    this._offset += bytes;    return value;}; </code></pre><hr><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a><br><a href="https://blog.csdn.net/caisini_vc/article/details/5356136" target="_blank" rel="noopener">https://blog.csdn.net/caisini_vc/article/details/5356136</a><br><a href="https://jin-yang.github.io/post/mysql-protocol.html" target="_blank" rel="noopener">https://jin-yang.github.io/post/mysql-protocol.html</a></p><p>HandShake:<br><a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a> ,  <a href="https://my.oschina.net/alchemystar/blog/833598" target="_blank" rel="noopener">https://my.oschina.net/alchemystar/blog/833598</a></p><p>com标识:<br><a href="https://dev.mysql.com/doc/internals/en/text-protocol.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/text-protocol.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;计划通过本地代理远程mysql，尝试实现透明缓存中间件功能这个需求，在实现过程中，需要对mysql协议的请求和下发包进行解析以便进一步处理，网络上有大量关于mysql协议的文章，但过于分散，而且mysql协议在4.1版本做了大升级，本文将涉及到的一部分整理汇总，资料来自mysql官网，网络blog，和npm上的mysql模块源码。&lt;/p&gt;
&lt;p&gt;代码部分经过nodejs的mysql模块和php的mysqli模块验证。&lt;/p&gt;
&lt;p&gt;此次只作为对mysql协议熟悉的练习，对数据变动自动清理相应缓存建议还是使用基于binlog的解析,然后通过消息机制更新。&lt;/p&gt;
    
    </summary>
    
      <category term="rongweiwei" scheme="http://xgfe.github.io/categories/rongweiwei/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="mysql" scheme="http://xgfe.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 React-Native 与 Redux 数据流</title>
    <link href="http://xgfe.github.io/2018/11/25/juga/%E6%B5%85%E8%B0%88React-Native%E4%B8%8ERedux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://xgfe.github.io/2018/11/25/juga/浅谈React-Native与Redux数据流/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.382Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。</p><a id="more"></a><h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React-Native 介绍"></a>React-Native 介绍</h4><ul><li><p>React-Native 在官网上给的定义是：使用 JavaScript 和 React 编写原生移动应用。在设计原理上是和 React 一致的，可以通过生命是的组件机制来搭建丰富多彩的用户界面。RN 产出的不是“网页应用”或者“HTML5应用”，RN 所产出的其实是一个真正的移动应用。从感受上来说和 Objective-C 或 Java 编写的应用基本是一样的。</p></li><li><p><a href="https://reactnative.cn/" target="_blank" rel="noopener">RN官网</a></p></li></ul><h4 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h4><ul><li><p>官网上有教大家如何构建一个新的 React-Native 应用，这里就不多说了，这里直接切入组件的开发。可以在项目里面新建一个 Component 组件文件夹，专门用来存放组件。在该文件家里面建一个 TestComponen 子文件夹，然后在此子文件下面再建 TestComponent.js 和TestComponentStyle.js 两个文件夹，组件的逻辑写在TestComponent.js 文件下，样式写在 TestComponentStyle.js 文件下。<br><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc82f8j20hk03uaaa.jpg" alt="文件结构"></p></li><li><p>JS文件分析</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">//引入Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>; <span class="comment">//引入RN原生组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;Style&#125; <span class="keyword">from</span> <span class="string">'./TestComponentStyle'</span>; <span class="comment">//引入样式</span></span><br></pre></td></tr></table></figure><ul><li>简单的计数器实现</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc2m1qj207g010dfq.jpg" alt="计数器"></p><p>点击加号数字动态变化 +1，点击减号数字动态 -1。首先这个组件由一个 Text 和两个  Button 组件组成，其中 Text 组件中有两个变量，children 作为对外暴露的属性，写在 this.props 里面，state 是组件内部的可变化的状态，写在 this.state 里面。<br>官网上是这样描述 props 和 state：我们使用两种数据来控制一个组件：props 和 state.props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用 state 。<br>这里先介绍一下 render 函数部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      children</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props; <span class="comment">//组件对外暴露的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state; <span class="comment">//组件内部的状态</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="comment">//返回要渲染的组件</span></span><br><span class="line">      &lt;View style=&#123;Style.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;Style.txt&#125;&gt;&#123;<span class="string">`<span class="subst">$&#123;children&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button title=&#123;'-'&#125; color=&#123;'red'&#125; onPress=&#123;this.clickBtnSub&#125;/</span>&gt;</span><br><span class="line">        &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;<span class="keyword">this</span>.clickBtnAdd&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件的结构由一个 View 组件包裹一个 Text ，两个 Button 组件。Text 组件为展示的数字名和数字大小，Button 则是两个加减按钮。</p><p>然后可以看到 Style.container 和 Style.txt 都是引自  TestComponentStyle.js 文件。接下来我们看一下该文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Style = StyleSheet.create(&#123;</span><br><span class="line"><span class="comment">// styles</span></span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'space-around'</span>,</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  txt: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个是 RN 样式的基本写法，这个文件专门放 css 层的东西。这里要注意的是 css 的属性值接受的是字符串形式，在 RN 里面的 css 很多样式的值都被阉割了，所以这点要特别注意，这里有个推荐的网站可以看常用的RN样式：<br><a href="https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html" target="_blank" rel="noopener">RN css 样式</a></p><p>然后可以看到 Button 组件里面分别有一个点击事件。clickBtnSub 事件处理减 1，clickBtnAdd 处理加 1。<br>这里我推荐是使用箭头函数来定义函数，就可以在该组件的作用域里面直接调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickBtnSub = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num - <span class="number">1</span>&#125;);<span class="comment">//调用setState()函数，改变组件内部的状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> clickBtnAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num + <span class="number">1</span>&#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h4><p>组件写好之后可以引入到某个功能模块中使用。这里我们可以建一个 TestModule 文件夹来存放模块文件，里面可以建这么几个文件。如下图<br><img src="https://wx2.sinaimg.cn/mw690/ba56005dgy1fxkcvcd0coj20ia08o755.jpg" alt="文件结构"><br>接下来我们一个一个来介绍这几个文件的用处。<br>其实上面的组件计数器，除了使用 setState 来改变数字还可以使用 Redux 来完成这件事。<br>接下来就让我们来看看如何使用 Redux 完成</p><ul><li>TestModule.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import部分省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;计数器&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;num&#125; = this.props.data /</span><span class="regexp">/从store取得的数据，在reducer里面初始化</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*引入计数器组件*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View style=&#123;Style.container&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;TestComponent children=&#123;'数字: '&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*使用Redux完成的计数器*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;Text&gt;&#123;num&#125;&lt;/</span>Text&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'-'</span>&#125; color=&#123;<span class="string">'red'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.sub(num)&#125; /&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.add(num)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  (state) =&gt; (&#123; <span class="comment">//state其实就是store.getState()，得到数据</span></span><br><span class="line">    data: state.modules[CONSTANTS.NAME]</span><br><span class="line">  &#125;),</span><br><span class="line">  (dispatch) =&gt; (&#123; <span class="comment">//dispatch是一个发布器他需要接受一个对象用于触发reducer</span></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    add: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.add(num)),</span><br><span class="line">    sub: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.sub(num))</span><br><span class="line">  &#125;)</span><br><span class="line">)(TestModule);</span><br></pre></td></tr></table></figure></li></ul><p>模块的主要页面内容都是写在这个文件里面，这里我们直接从 components 引入了 TestComponent 组件进行使用。直接将组件当成标签名使用 <testcomponent>。这就是自定义组件方便的地方。中间可以看到组件渲染不一定要都放在 render() 里面，可以利用一个渲染函数，单独抽出来，这样可以让程序的结构上看起来更加明了，不要让所有的子组件都堆积在 render() 函数中。当然如果抽出来的组件内容太少，就没必要抽了。<br>这个文件的最下面 connect 函数是 Provider 提供的一种 store 注入方式，其中封装了两个函数，第一个函数其实是 store.getState() ，是从 store 得到数据的。<br>第二个函数 dispatch 是一个触发器，在里面写 action 函数来触发 reducer 来对数据进行所需要的操作。dispatch 触发 TestModuleActions.js 里面的函数。下面就介绍一下 TestModuleActions.js 文件<br>这里我们写了一个加一个减函数，接着在 actions.js 文件里定义这两个 action 函数。</testcomponent></p><ul><li>TestModuleActios.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ADD,</span><br><span class="line">  SUB</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ADD, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: SUB, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件主要是写 actions 的文件，定义 action，dispatch中根据 type 类型去 TestModuleReducers.js 那处理数据。通过 payload 把数据传到 reducer 里面。</p><ul><li>TestModuleConstants.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAME = <span class="string">'testmodule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action types</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/ADD`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/SUB`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件用来放全局常量。这里定义了 ADD 和 SUB 。</p><ul><li>TestModuleReducer.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ADD, SUB&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">//初始化数据的地方</span></span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123; <span class="comment">//处理数据的地方</span></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  [ADD]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SUB]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, initialState);</span><br></pre></td></tr></table></figure></li></ul><p>reducer 利用 action.payload 拿到从 action 传来的数据，处理数据，处理完返回。<br>这里就要说一下Redux的数据流了，请先看一下下图：<br><img src="https://wx3.sinaimg.cn/mw690/ba56005dgy1fxkcvc6dthj20xm0mk77l.jpg" alt="Redux Flow"></p><p>(图片来自网上)<br>这里我们在TestModule.js 文件中的 connect 中 dispatch( action ) ，把原先的计数器中数字 num (图中 previousState )，和 action ( ADD 或 SUB )传到了 reducer 里面，根据 actions 文件里面的 action 的 TYPE 来执行各自的数据处理。处理完之后就有新的 newState 传到 Store ，再传到组件中，驱动组件改变状态重新渲染。</p><ul><li>index.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./TestModule'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./TestModuleReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./TestModuleActions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NAME&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  NAME,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  reducer,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件将 NAME，module，reducer，actions 暴露出去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 RN + Redux 为基础框架开发已有三个多月，很多东西都还需要多加学习研究，这只是最基础的组件和模块开发。</p><p>组件开发总的时间为十的话，一定要思考占七，动手写占三，认真的多思考组件的构造，这样在动手写的时候才能尽量的避免结构的冗余，或者是样式的冗余，而且要想为什么做这个组件，必需能在某个项目中能多次的使用该组件，这样组件的开发才会变得有意义，不然一个组件只用一次的话，就没有必要单独拿出来封装成一个组件。另外就是组件写的过程尽量的思考拓展性，很多结构不要写死了，这次组件可能只需要展示 2 个 tab，但是下一次就不一定了，所以写的时候要多想。</p><p>模块开发的时候，尽量保持结构层次的清晰，这样的话代码的维护就会得比较轻松，模块里有很多独立的功能部分可以单抽出来做成一个渲染函数，这样就能让 render 函数看起来没那么的冗余，且结构不会过于复杂。一些点击事件和逻辑功能也是能单独抽出来写成事件函数，这样的话，调试出问题的时候就可以快速定位到问题代码块。还有就是尽量避免写一些重复的组件，能简化的就简化，可以考虑使用 map 函数来渲染重复的组件。</p><p>虽然这里用 Redux 也实现了计数器，但是其实是杀鸡用牛刀了，这样的简单的数据重新渲染其实大可不必，用 setState 就可以了，当然 Redux 也有其优点，他让数据和我们的组件模块解耦，数据单独处理了，不需要在每一个组件中来对 state 进行管理，需要的数据从上游作为 props 传进来了。不过经常可以看到这么一句话，如果你不知道你为什么需要 Redux，那你就是不需要 Redux..   (=. = redux 对于新手真的有点不友好)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/Helloyongwei/article/details/82937808" target="_blank" rel="noopener">Redux 的数据流</a></li><li><a href="https://www.jianshu.com/p/2a20c8485a90" target="_blank" rel="noopener">看了我这篇 RN 你就入门了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="juga" scheme="http://xgfe.github.io/categories/juga/"/>
    
    
      <category term="React-Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="http://xgfe.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>宏任务和微任务</title>
    <link href="http://xgfe.github.io/2018/11/19/zhangpeng/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    <id>http://xgfe.github.io/2018/11/19/zhangpeng/宏任务与微任务/</id>
    <published>2018-11-18T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.406Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要介绍事件循环，第二部分介绍宏任务和微任务。</p><a id="more"></a><h2 id="一、深入事件循环"><a href="#一、深入事件循环" class="headerlink" title="一、深入事件循环"></a>一、深入事件循环</h2><h3 id="1-宏任务"><a href="#1-宏任务" class="headerlink" title="1.宏任务"></a>1.宏任务</h3><p>事件循环不仅仅是包括事件队列，而是至少要具有两个队列，除了事件，还要保持浏览器执行的其他的操作，这些操作称为任务，并且可以分为两类，宏任务和微任务。<br>宏任务：<br>（1）创建主文档对象，解析HTML，执行主线或者全局的javascript的代码，更改url以及各种事件。<br>（2）页面加载，输入，网络事件，定时器。从浏览器角度看，宏任务是一个个离散的，独立的工作单元。<br>（3）运行完成后，浏览器可以继续其他调度，重新渲染页面的UI或者去执行垃圾回收</p><h3 id="2-微任务"><a href="#2-微任务" class="headerlink" title="2.微任务"></a>2.微任务</h3><ul><li>微任务是更小的任务，微任务更新应用程序的状态，但是必须在浏览器任务继续执行其他任务之前执行，浏览器任务包括重新渲染页面的UI。</li><li>微任务包括Promise的回调函数，DOM发生变化等，微任务需要尽可能快地，通过异步方式执行，同时不能产生全新的微任务。</li><li>微任务能使得我们能够在重新渲染UI之前执行指定的行为，避免不必要的UI重绘，UI重绘会使得应用状态不连续</li></ul><h3 id="3-事件循环"><a href="#3-事件循环" class="headerlink" title="3.事件循环"></a>3.事件循环</h3><p>ECMA的规范没有提及到事件循环，但在HTML规范里却有提及<br>（1）里面也讨论了宏任务和微任务的概念<br>（2）ECMA规范提及到了Promise<br>（3）虽然只在HTML的规范里定义了事件循环，但是在例如node的环境中也在使用<br>事件循环的实现至少应该含有一个用于宏任务队列和微任务队列，大部分的实现一般会更多用于不同类型的宏任务和微任务的队列，这样使得事件循环可以根据任务类型进行优先的处理，比如，优先去考虑对性能敏感的任务，比如用户输入，另一个方面，由于javascript的执行的环境比较多，如果发现所有的任务都在一个队列的事件循环，也不要惊讶。<br>事件循环基于两个基本的原则，一次处理一个任务，一个任务开始后直到运行完成，不会被其他任务中断。<br>从全局来看，在一次的迭代中，事件循环首先检查宏任务队列，如果宏任务在等待，则立刻开始执行宏任务，直到该任务运行完成或者队列处于空的状态，事件循环将去处理微任务队列，直到队列中所有微任务执行完毕，注意处理宏任务和微任务的区别，在一次的迭代中，最多处理一个宏任务，其余的都会在队列中去等待。但是队列中的所有的微任务都会被处理。<br>当微任务处理完成并且清空的时候，事件循环会检查是否需要更新UI渲染，如果是，则会重新渲染UI视图，至此，当前事件循环结束，之后将回到第一个环节，开启新的一轮的事件循环。<br>两类任务队列都是独立于事件循环的，这意味着任务队列的添加行为也发生在事件循环之外，如果不是这样的设计，会导致执行javascript的代码的时候，发生的任何的事件都会被忽略。<br>因为javascript基于单线程的执行模型，所以这两个任务都是逐个执行的，当一个任务开始执行后，在完成前，中间不会被任何其他的任务中断，除非浏览器决定终止执行该任务，例如，某些任务执行时间过长或内存占用过大。<br>所有的微任务会在下一次渲染之前执行完成，因为他们的目标是在渲染前更新应用程序状态。<br>浏览器通常会尝试每秒渲染60次页面，以达到每秒60fps的速度，60fps通常会检测体验是否平滑流畅的标准，比如在动画里，这意味着浏览器会尝试在16ms内渲染一帧，更新渲染是怎样发生在循环之内的，因为在页面渲染的时候，任何任务都无法再进行修改，这些的设计和原则都意味着，如果都想去实现平滑的应用，我们是没有太多的时间浪费在处理单个事件循环任务，在理想的情况下，单个任务和改任务附属的所有的微任务，都应在16ms之内去执行。<br>现在，在浏览器完成页面渲染，进入下一轮的事件循环迭代后，可能会发生3种的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">在另一个16ms结束前，事件循环执行到&quot;是否需要渲染&quot;的决策的环节。因为更新UI是一个复杂的操作，如果没有显示指定需要的页面渲染，浏览器可能不会选择在当前的循环中执行的UI渲染操作</span><br><span class="line">在最后的一个渲染操作完成后大约16ms，事件循环执行到&quot;是否需要进行渲染&quot;的决策环节，在这种情况下，浏览器会进行UI更新，以便用户能够感受到流畅的用户体验。</span><br><span class="line">在执行下一个任务和相关的所有的微任务耗时超过16ms，在这种情况下，浏览器将无法以目标帧率重新渲染页面，且UI无法更新，如果任务的代码执行不耗费过多的时间，这是的延迟可能会无法察觉到，尤其是当页面中没有太多的操作，反之，如果耗时过多，或者页面上有运行动画，用户可能会察觉到网页卡顿没有响应，在这种极端的情况下，用户可能会觉得网页挂掉了。</span><br><span class="line">在处理函数的发生的频率的时候以及耗时的操作，比如处理鼠标的移动的事件，导致大量的事件进入队列，可能会导致网页的性能低下。  </span><br><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">主线程javascript代码执行时间需要15ms</span><br><span class="line">第一个单击事件处理器需要运行8ms</span><br><span class="line">第二个单击事件处理器需要运行5ms</span><br><span class="line">让我们想一下，我们的手很快的用户在代码执行后5ms的时候单击第一个按钮，随后在12ms时单击第二个按钮，我们需要去了解下浏览器的原理，主线程的代码块需要运行15ms，第一个按钮的单击事件需要运行8ms,第二个的单击事件需要大约5ms，在5ms单击第一个按钮，第12ms单击第二个按钮，程序主线程javascript</span><br><span class="line">代码开始，立刻从DOM获取firstButton和secondButton元素，并注册firstHandle和secondHandle的事件处理器。</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">主线程执行15ms,在主线程执行过程中，用户在第5ms单击firstButton，第12ms单击secondButton.</span><br><span class="line">由于javascript基于单线程执行模型，单击firstButton并不会立刻执行对应的处理器。记住，一个任务</span><br><span class="line">一旦开始执行，就不会被另外一个任务中断，firstButton的事件处理器则进入任务队列，等待执行。当单击secondButton时候也会发生另外的一种情况，对应的事件的处理器进入队列，等待执行，注意，事件监测和添加任务是独立于事件循环的，尽管主线程仍在执行，仍然可以向队列添加任务。</span><br><span class="line">在第12ms的时候，</span><br><span class="line">1.执行主线程javascript代码，执行当前任务。</span><br><span class="line">2.单击firstButton，单击firstButton的时候，创建事件</span><br><span class="line">3.单击secondButton,单击secondButton的时候，创建事件</span><br><span class="line">在接着在程序到15ms的时候，发生了一件有趣的事情，主线程javascript代码已经执行完成了，任务执行完成后，事件循环转向处理微任务，如果微任务不存在，则跳过此步骤直接更新UI，UI发生变化的时候需要消耗一些时间。这样事件循环完成第一层交互，通过任务队列，进入第二次交互。</span><br><span class="line">接着，firstButton单击任务开始执行，执行firstHandle,需要执行8ms且不被中断，secondButton在队列中等待。在第15ms的时候，任务队列中含有两个事件，第一个任务正在执行，接着，第23ms的时候，firstButton单击任务执行完成，对应的任务从任务队列中移除，浏览器又一次检查微任务队列，微任务仍是空的，那么如果需要的话，重新渲染页面。</span><br><span class="line">最后在第三次的循环迭代中，secondButton单击事件开始执行，secondHandle需要执行5ms,执行完成以后，在第28ms的时候，任务队列是空的。尽管在第12ms的时候单击secondButton，但是对应的事件处理任务在第23ms时才开始执行。</span><br></pre></td></tr></table></figure></p><h3 id="4-宏任务和微任务"><a href="#4-宏任务和微任务" class="headerlink" title="4.宏任务和微任务"></a>4.宏任务和微任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;firstButton&quot;&gt;&lt;/button&gt;  </span><br><span class="line">&lt;button id=&quot;secondButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const fristButton = document.getElementById(&apos;firstButton&apos;)</span><br><span class="line">const secondButton = document.getElementById(&apos;secondButton&apos;)</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">secondButton.addEventListener(&quot;click&quot;, function secondHandle()&#123;</span><br><span class="line">    /* Some click runs 5 ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 15ms */</span><br><span class="line">&lt;/script&gt;     </span><br><span class="line">第5ms单击firstButton</span><br><span class="line">第12m单击secondButton</span><br><span class="line">firstButton 的单击事件处理函数firstHandle需要执行8ms</span><br><span class="line">secondButton 的单击事件的处理函数secondHandle需要执行5ms</span><br><span class="line">在firstHandle代码中我们创建立刻兑现的Promise,并需要运行4ms的传入的回调函数。因为Promise表示当前未知的一个未来值，因此Promise处理函数总是异步执行。</span><br><span class="line">我们创建立刻兑现的Promise，说实话，Javascript引擎不会这么做，因为我们知道Promise成功兑现，但是，为了连续性，javascript引擎不会这么做，仍然会在firstHandle代码执行，需要运行8ms完成之后再异步调用回调函数，通过创建微任务，将回调放入微任务队列。</span><br><span class="line">在第12ms时候，可以完全看出来，当主线程javascript代码正在处理中，单击firstButton和secondButton按钮这两个任务处于等待状态，但是，除了宏任务队列之外，在12ms时候微任务队列是空的，下一个是第15ms的时候，此时主线程运行结束，完成执行了一个任务时候，事件循环会检查微任务队列，若微任务队列是空的时候，则按需进行渲染页面，在下一个事件循环迭代中，处理firstButton按钮单机相关任务的代码如下。</span><br><span class="line">firstButton.addEventListener(&quot;click&quot;, function firstHandle()&#123;</span><br><span class="line">    Promise.resolve().then(()=&gt;&#123;</span><br><span class="line">        /* Some run 4ms */</span><br><span class="line">    &#125;)</span><br><span class="line">    /* Some click runs 8 ms */</span><br><span class="line">&#125;)</span><br><span class="line">firstHandle函数通过调用Promise创建一个已经兑现的Promise，传入的回调函数一定会执行，此时创建了一个调用回调函数的微任务。将改微任务放置到微任务队列，第一个按钮的单击事件处理器继续执行8ms，当前任务队列，在第23ms时重新查看程序执行的任务的队列，此时firstButton单击处理器执行完成，并移除队列。此时，事件循环必须选择接下来执行的任务，在程序第12ms的时候，添加了一个宏任务处理secondButton单击事件，在程序执行了15ms的时候，添加了一个微任务处理PROMISE成功兑现。</span><br><span class="line">如果是按照先后的顺序，那么应该是先执行secondButton才是公平的，但是我们已经提到过，微任务是很小的任务，需要尽可能快的执行，微任务具有优先的执行权，就会发现每当执行一个任务的时候，事件循环首先会检查微任务队列，目的是在处理其他任务之前把其他所有的微任务执行完毕。</span><br><span class="line">正因为这样，当firstButton单击的事件执行完成之后，立即执行Promise成功的回调函数，在更早的队列中secondButton单击任务执行完毕则继续等待。</span><br><span class="line">当两个宏任务之间重新渲染页面，当且仅当两个宏任务之间没有微任务。可以在主线程和第一个按钮单击任务之间重新渲染页面，但是在第一个按钮单击任务处理完成之后无法立刻重新渲染页面，需要优先处理Promise。</span><br><span class="line">注意到无法停止微任务运行，无法在微任务队列之前添加其他微任务，所有微任务的优先权高于secondButton单击任务，只有当微任务队列是空的时候，事件循环才会开始重新渲染页面，继续执行secondButton单击任务，这点需要注意</span><br></pre></td></tr></table></figure><h3 id="5-计时器"><a href="#5-计时器" class="headerlink" title="5.计时器"></a>5.计时器</h3><p>计时器是能延迟一段代码的运行，延迟时长是指定的时长，将长时间运行的任务分解为不阻塞循环的小任务，以阻止浏览器渲染，在事件循环中执行计时器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;myButton&quot;&gt;&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">在这个只有一个按钮，注册了两个计时器，注册延迟计时器延迟10ms。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">延迟执行回调函数需要执行6ms,接着，我们也注册了一个间隔执行计时器，每隔10ms执行一次。</span><br><span class="line">setInterval(function intervalHandle()&#123;</span><br><span class="line">    /* run 8ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">间隔执行的回调函数需要执行8ms,我们继续注册一个单击事件的处理器，需要执行10ms。</span><br><span class="line">const myButton = document.getElementById(&apos;myButton&apos;)</span><br><span class="line">myButton.addEventListener(&apos;click&apos;, function clickHandle()&#123;</span><br><span class="line">    /* run 10ms */</span><br><span class="line">&#125;)</span><br><span class="line">/* run 18ms */</span><br><span class="line">假如某个没有耐心的的用户在程序中6ms时候快速单击按钮，</span><br><span class="line">在队列中第一个任务是执行主线程javascript代码，需要运行18ms,在执行的过程中，发生了3件重要的事件。</span><br><span class="line">在0ms的时候，延迟计时器延迟10ms执行，延迟计时器间隔也是10ms.计时器的引用保存在浏览器。</span><br><span class="line">在6ms，单击鼠标</span><br><span class="line">在10ms时，延迟计时器到期，间隔计时器的第一个时间间隔触发。</span><br><span class="line">从之前的研究中我们已经知道，一个任务一旦开始执行，就无法呗其他任务中断。新创建的任务都在任务队列中耐心等待运行时机。当第6ms时候单击按钮，该任务被添加到队列中，类似的情况在10ms时发生，此时计时器到期，间隔的计时器触发，计时器事件与input输入框的输入事件类似，都会被添加到队列中。注意，延迟计时器和间隔计时器都在10ms之后，添加对应的任务队列中。</span><br><span class="line">运行到18ms之后，初始化的代码结束执行，由于微任务队列没有任务，因此浏览器可以重新渲染，进行下一次事件循环迭代，在18ms代码初始化结束执行，3个代码块正在等待执行，单击处理器，延迟计时处理器，和间隔计时器，这意味着单击事件处理器开始执行，setTimeout函数只到期一次，setInterval函数则不同，setTnterval会持续执行到被清除，因此，在第20ms的时候，setInterval又一次触发，但是，此时间隔计时器的被清除，因此，在第20ms时，setInterval又一次触发，但是，此时时间间隔计时器的已经在队列中等待执行，改触发被终止，浏览器不会同时创建两个相同的间隔计时器。</span><br><span class="line">单击事件处理器在第28ms时候运行完成，浏览器在事件循环进行下一次迭代之前重新渲染页面，第28ms,事件循环进行下一次迭代，执行延迟计时器任务。</span><br><span class="line">setTimeout(function timeoutHandle()&#123;</span><br><span class="line">    /* run 6ms */</span><br><span class="line">&#125;,10)</span><br><span class="line">期待延迟计时器恰好10ms之后执行，这并不奇怪，但是28ms才执行延迟的计时器。</span><br><span class="line">这就是为什么我们要特别的小心，计时器能给我们提供一种异步延迟执行代码片段的能力，至少要延迟指定的毫秒数，因为javascript是单线程的本质，我们只能控制计时器何时被加入到队列，而无法控制什么时候执行，延迟计时器处理器需要执行6ms,将会在第34ms的时候，但是在第30ms的时候，又与另外一个间隔计时器到期，这一次让然不会添加新的间隔计时器到队列中，因为队列中已经有一个与之相匹配的间隔计时器，在第34ms时，延迟计时处理器运行结束，浏览器又一次获得重新渲染页面的机会，然后进入下一个事件循环迭代。</span><br><span class="line">最后，间隔计时处理器在第34ms的时候才开始执行，此时距离添加到对列相差了24ms,又一次强调了仅仅知道计时器添加到队列中的时间，而不是转却的执行时间。</span><br><span class="line">间隔计时器才需要执行8ms，当它执行的时候，另一个间隔计时器在40ms时候到期，此时，由于间隔处理器正在执行，不是在队列中等待，设置间隔10ms并不意味着每个10ms处理器就会执行完成，由于在队列中等待，每一个任务的执行时间有可能不同，一个接一个的完成。</span><br><span class="line">最终，50ms之后，时间间隔稳定每一个10ms执行一次，记住这个概念，事件循环一次只能处理一个任务，我们永远不能确定定时器处理程序是否会执行我们期望的确定时间，间隔处理程序就是这样，我们是期待，10，20，30，40，50，60，70的时候触发，回调函数确实在34,42,50,60,和70时候执行，少执行了两次回调函数，有几个回调函数没有在预期时间点执行。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了宏任务和微任务。本文分为两个部分，第一部分是主要介绍事件循环，第二部分介绍宏任务和微任务。&lt;/p&gt;
    
    </summary>
    
      <category term="ZHANGPENG" scheme="http://xgfe.github.io/categories/ZHANGPENG/"/>
    
    
      <category term="宏任务和微任务" scheme="http://xgfe.github.io/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>谈谈Observable</title>
    <link href="http://xgfe.github.io/2018/08/23/objectisundefined/observable/"/>
    <id>http://xgfe.github.io/2018/08/23/objectisundefined/observable/</id>
    <published>2018-08-23T04:00:00.000Z</published>
    <updated>2019-05-05T10:15:56.830Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。</p><a id="more"></a><h2 id="Observable是什么"><a href="#Observable是什么" class="headerlink" title="Observable是什么"></a>Observable是什么</h2><p>数据处理过程中，存在数据的生产者 (Producer) 和数据的消费者 (Consumer) ，处理方式基本分为拉取 (Pull) 和 推送 (Push)两种。</p><table><thead><tr><th></th><th>生产者</th><th>消费者</th></tr></thead><tbody><tr><td><strong>拉取</strong></td><td><strong>被动的:</strong> 当被请求时产生数据。</td><td><strong>主动的:</strong> 决定何时请求数据。</td></tr><tr><td><strong>推送</strong></td><td><strong>主动的:</strong> 按自己的节奏产生数据。</td><td><strong>被动的:</strong> 对收到的数据做出反应。</td></tr></tbody></table><p>在拉取体系中，由消费者来决定何时从生产者那里接收数据。生产者本身不知道数据是何时交付到消费者手中的。每个 JavaScript 函数都是拉取体系。函数是数据的生产者，调用该函数的代码通过从函数调用中“取出”一个单个返回值来对该函数进行消费。ES2015 引入了一种新的的拉取体系, generator 和 iterator。由消费者调用 iterator.next() 从 iterator(生产者) 那“取出”值。</p><p>在推送体系中，由生产者来决定何时把数据发送给消费者。消费者本身不知道何时会接收到数据。在当今的 JavaScript 世界中，Promise 是最常见的推送类型。Promise(生产者) 将一个 resolve 过的值传递给已注册的回调函数(消费者)，但不同于函数的是，由 Promise 来决定何时把值“推送”给回调函数。</p><p><strong>Observable 是多个值的生产者，并将值“推送”给观察者(消费者)。</strong></p><pre><code>Function 是惰性的评估运算，调用时会同步地返回一个单一值。Generator 是惰性的评估运算，调用时会同步地返回零到(有可能的)无限多个值。Promise 是最终可能(或可能不)返回单个值的运算。Observable 是惰性的评估运算，它可以从它被调用的时刻起同步或异步地返回零到(有可能的)无限多个值。</code></pre><p><strong>Observable 像是没有参数, 但可以泛化为多个值的函数。</strong></p><p>考虑如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="keyword">var</span> y = foo.call(); <span class="comment">// 等同于 foo()</span></span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure></p><p>我们期待看到的输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br></pre></td></tr></table></figure></p><p>使用Rx.js，你可以使用 Observable 重写上面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>输出是一样的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="string">"Hello"</span></span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure></p><p>这是因为函数和 Observable 都是惰性运算。如果你不调用函数，console.log(‘Hello’) 就不会执行。Observable 也是如此，如果你不“调用”它(使用 subscribe)，console.log(‘Hello’) 也不会执行。此外，“调用”或“订阅”是独立的操作：两个函数调用会触发两个单独的副作用，两个 Observable 订阅同样也是触发两个单独的副作用。EventEmitters 共享副作用并且无论是否存在订阅者都会尽早执行，Observable 与之相反，不会共享副作用并且是延迟执行。</p><p>订阅 Observable 类似于调用函数。</p><p>如果你使用console.log包围一个函数调用，像这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.call());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>你会看到这样的输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>使用 Observable 来做同样的事：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>这证明了 foo 的订阅完全是同步的，就像函数一样。Observable 传递值可以是同步的，也可以是异步的。<br>那么 Observable 和 函数的区别是什么呢？Observable 可以随着时间的推移“返回”多个值，这是函数所做不到的。你无法这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>; <span class="comment">// 死代码，永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数只能返回一个值。但 Observable 可以这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>); <span class="comment">// “返回”另外一个值</span></span><br><span class="line">  observer.next(<span class="number">200</span>); <span class="comment">// 还可以再“返回”值</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure></p><p>同步输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br></pre></td></tr></table></figure></p><p>但你也可以异步地“返回”值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">  observer.next(<span class="number">42</span>);</span><br><span class="line">  observer.next(<span class="number">100</span>);</span><br><span class="line">  observer.next(<span class="number">200</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(<span class="number">300</span>); <span class="comment">// 异步执行</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>);</span><br><span class="line">foo.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>);</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;before&quot;</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">42</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">&quot;after&quot;</span><br><span class="line">300</span><br></pre></td></tr></table></figure></p><p>结论:</p><pre><code>func.call() 意思是 &quot;同步地给我一个值&quot;observable.subscribe() 意思是 &quot;给我任意数量的值，无论是同步还是异步&quot;</code></pre><h2 id="创建Observable"><a href="#创建Observable" class="headerlink" title="创建Observable"></a>创建Observable</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> once = <span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (called) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    called = <span class="literal">true</span></span><br><span class="line">    f(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// just return a subscribe function</span></span><br><span class="line">  <span class="comment">// error and complete can be invoked just once</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next, error, complete</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unsubscribe = f(&#123;</span><br><span class="line">      next: <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next(val)</span><br><span class="line">      &#125;,</span><br><span class="line">      error: once(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        error &amp;&amp; error(err)</span><br><span class="line">      &#125;),</span><br><span class="line">      complete: once(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        complete &amp;&amp; complete()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should return a dispose function</span></span><br><span class="line">    <span class="comment">// think case like timeout, interval, websocket connection...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      unsubscribe &amp;&amp; unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">const</span> number$ = create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observer.next(<span class="number">1</span>)</span><br><span class="line">  observer.next(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  observer.error(<span class="built_in">Error</span>(<span class="string">'crash'</span>))</span><br><span class="line"></span><br><span class="line">  observer.next(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe</span></span><br><span class="line">number$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// error: Error: crash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval = <span class="function"><span class="params">delay</span> =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), delay)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line"></span><br><span class="line">    clearInterval(timer)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> interval$ = interval(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unsubscribe = interval$(</span><br><span class="line">  val =&gt; <span class="built_in">console</span>.log(<span class="string">'next:'</span>, val),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">'error:'</span>, err),</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'completed'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// next: 0</span></span><br><span class="line"><span class="comment">// next: 1</span></span><br><span class="line"><span class="comment">// next: 2</span></span><br><span class="line"><span class="comment">// next: 3</span></span><br><span class="line"><span class="comment">// completed</span></span><br><span class="line"></span><br><span class="line">setTimeout(unsubscribe, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>Observable 作为多个值的生产者这样的数据抽象，在使用时，我们还需要操作符。操作符是允许复杂的异步代码以声明式的方式进行轻松组合的基础代码单元。操作符本质上是一个纯函数 (pure function)，它接收一个 Observable 作为输入，并生成一个新的 Observable 作为输出。</p><p><img src="https://cn.rx.js.org/img/map.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(f(x))</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/filter.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      f(x) &amp;&amp; observer.next(x)</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/merge.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        i === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineLatest.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineLatest = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        !(i <span class="keyword">in</span> arr) &amp;&amp; (k += <span class="number">1</span>)</span><br><span class="line">        arr[i] = x</span><br><span class="line"></span><br><span class="line">        k === l &amp;&amp; observer.next(arr)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        n === l &amp;&amp; observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/combineAll.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> combineAll = <span class="function">(<span class="params">...observables</span>) =&gt;</span> observer =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  observables.forEach(<span class="function">(<span class="params">observable, i</span>) =&gt;</span> &#123;</span><br><span class="line">    observable(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">      !(i <span class="keyword">in</span> arr) &amp;&amp; (n += <span class="number">1</span>)</span><br><span class="line">      arr[i] = x</span><br><span class="line"></span><br><span class="line">      n === l &amp;&amp; observer(arr)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/share.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> share = <span class="function"><span class="params">observable</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> finished = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> obs = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> observable(</span><br><span class="line">    x =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.next(x)),</span><br><span class="line">    err =&gt; obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.error(err)),</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      finished = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      obs.forEach(<span class="function"><span class="params">ob</span> =&gt;</span> ob.complete())</span><br><span class="line">      obs = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (finished || obs.indexOf(observer) !== <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obs.push(observer)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lazy subscribe until the first observer occurs</span></span><br><span class="line">    obs.length === <span class="number">1</span> &amp;&amp; start()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/take.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> take = <span class="function"><span class="params">n</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    observer.complete()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> unsubscribe = observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      observer.next(x)</span><br><span class="line"></span><br><span class="line">      n--</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">        observer.complete()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    observer.complete</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concat.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = <span class="function">(<span class="params">...observables</span>) =&gt;</span> create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> l = observables.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= l) &#123;</span><br><span class="line">      <span class="keyword">return</span> observer.complete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    observables[n](</span><br><span class="line">      x =&gt; observer.next(x),</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        f(n + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f(<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/concatMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concatMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> observables = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> c = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> g = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flushing || !observables.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flushing = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> observable = observables.shift()</span><br><span class="line"></span><br><span class="line">    observable(</span><br><span class="line">      x =&gt; &#123;</span><br><span class="line">        observer.next(x)</span><br><span class="line">      &#125;,</span><br><span class="line">      observer.error,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        flushing = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c) &#123;</span><br><span class="line">          observables = <span class="literal">null</span></span><br><span class="line">          <span class="keyword">return</span> observer.complete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g()</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observables.push(f(x))</span><br><span class="line">      g()</span><br><span class="line">    &#125;,</span><br><span class="line">    observer.error,</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      c = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><img src="https://cn.rx.js.org/img/switchMap.png"><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> switchMap = <span class="function"><span class="params">f</span> =&gt;</span> observable =&gt; create(<span class="function"><span class="params">observer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> current</span><br><span class="line">  <span class="keyword">let</span> unsubscribe</span><br><span class="line"></span><br><span class="line">  observable(</span><br><span class="line">    x =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (unsubscribe) &#123;</span><br><span class="line">        unsubscribe()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      current = f(x)</span><br><span class="line"></span><br><span class="line">      unsubscribe = current(</span><br><span class="line">        x =&gt; observer.next(x),</span><br><span class="line">        (err) =&gt; &#123;</span><br><span class="line">          observer.error(err)</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">          observer.complete()</span><br><span class="line"></span><br><span class="line">          unsubscribe()</span><br><span class="line">          unsubscribe = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从数据处理的拉取和推送的方式着手，了解了 Observable 是基于推送模型的多值生产者的抽象，像是没有参数, 但可以泛化为多个值的函数。通过代码实现了一个 Observable 的创建函数，还实现了很多操作符。这只是个开始，在工作和学习中，你要认真思考自己的场景，观察这个场景中是不是存在着类似多个管道产生值，这些管道也存在着组合变换的逻辑，这时候，Observable 就可以大显身手了。从编程范式上来讲，使用 Observable，其实是 反应式编程（Reactive Programming） 的思维，它可以帮助我们摆脱命令式的状态处理，状态和逻辑杂合在一起，用声明式的方式去组合我们的逻辑，希望你能去探索下 Reactive Programming 和 Functional Reactive Programming的世界。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank" rel="noopener">The introduction to Reactive Programming you’ve been missing</a></li><li><a href="https://zhuanlan.zhihu.com/p/20213244" target="_blank" rel="noopener">谈谈FRP和Observable（一）</a></li><li><a href="http://jerryzou.com/posts/rxjs-practice-01/" target="_blank" rel="noopener">RxJS 实战篇（一）拖拽</a></li><li><a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">http://reactivex.io/rxjs/</a></li><li><a href="https://cn.rx.js.org/manual/overview.html" target="_blank" rel="noopener">cn.rx.js.org</a></li><li><a href="https://github.com/btroncone/learn-rxjs" target="_blank" rel="noopener">learn-rxjs</a></li><li><a href="https://github.com/ichpuchtli/awesome-rxjs" target="_blank" rel="noopener">awesome-rxjs</a></li><li><a href="https://github.com/staltz/xstream" target="_blank" rel="noopener">xstream</a></li><li><a href="https://github.com/paldepind/flyd" target="_blank" rel="noopener">flyd</a></li><li><a href="https://github.com/staltz/callbag-basics/" target="_blank" rel="noopener">callbag-basics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是利用Rx.js介绍Observable相关的一些概念，以及通过实现Observable的创建、一些常用的操作符了解Observable的执行原理。&lt;/p&gt;
    
    </summary>
    
      <category term="tianzhen" scheme="http://xgfe.github.io/categories/tianzhen/"/>
    
      <category term="Observable" scheme="http://xgfe.github.io/categories/tianzhen/Observable/"/>
    
    
      <category term="Observable" scheme="http://xgfe.github.io/tags/Observable/"/>
    
      <category term="RxJS" scheme="http://xgfe.github.io/tags/RxJS/"/>
    
      <category term="Functional Reactive Programming" scheme="http://xgfe.github.io/tags/Functional-Reactive-Programming/"/>
    
  </entry>
  
  <entry>
    <title>angularjs的双向数据绑定</title>
    <link href="http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
    <id>http://xgfe.github.io/2018/08/15/yangxiaotong/angularjs双向绑定/</id>
    <published>2018-08-15T13:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.402Z</updated>
    
    <content type="html"><![CDATA[<p>angularjs的双向数据绑定原理及简单的实现。</p><a id="more"></a><p>之前对vue.js的双向绑定比较感兴趣，自己动手实现了一个类似于vue.js的mvvm框架。vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。其核心代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">this.watch = function(obj, callback) &#123;</span><br><span class="line">this.$observeObj = function() &#123;</span><br><span class="line">var that = this;</span><br><span class="line">this.callback = callback;</span><br><span class="line">//console.log(Object.keys(obj));</span><br><span class="line">Object.keys(obj).forEach(function(prop) &#123;</span><br><span class="line">var val = obj[prop];</span><br><span class="line">Object.defineProperty(obj, prop, &#123;</span><br><span class="line">get: function() &#123;</span><br><span class="line">return val;</span><br><span class="line">&#125;,</span><br><span class="line">set: function(newVal) &#123;</span><br><span class="line">var temp = val;</span><br><span class="line">//console.log(newVal);</span><br><span class="line">val = newVal;</span><br><span class="line">//通知所有订阅者改变</span><br><span class="line"></span><br><span class="line">that.cache.forEach(function(item) &#123;</span><br><span class="line">if (item[prop]) &#123;</span><br><span class="line">item[prop] = newVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">that.callback();</span><br><span class="line">&#125;,    </span><br><span class="line">enumerable: true,</span><br><span class="line">   configurable: true</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.$observeObj();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>set</code>属性在改变数据的同时触发视图的更新。</p><p>angularjs实现数据双向绑定与vue.js有所不同，它依赖于脏值检测，这里我写了一个简易的版本，其主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">initWatch() &#123;  </span><br><span class="line">    for (let i = 0, len = this.elements.length; i &lt; len; i++) &#123;</span><br><span class="line">        //用来保证初值的正常加载，以及当我改变input框中的值为空时能正常显示</span><br><span class="line">        this.flags.push(false);</span><br><span class="line">        this.watch(() =&gt; &#123;</span><br><span class="line">            let value = this.elements[i].value;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            let key = this.elements[i].getAttribute(&apos;ng-model&apos;);</span><br><span class="line">            const elementType = this.elements[i].tagName.toLowerCase();</span><br><span class="line"></span><br><span class="line">            this.data[key] = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            //设置属性值</span><br><span class="line">            if (elementType === &apos;input&apos; || elementType === &apos;textarea&apos; || elementType === &apos;select&apos;) &#123;</span><br><span class="line">                this.elements[i].value = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.elements[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (let j = 0, len = this.bind.length; j &lt; len; j++) &#123;</span><br><span class="line">                let item = this.bind[i].getAttribute(&apos;ng-bind&apos;);</span><br><span class="line">                if (item === key) &#123;</span><br><span class="line">                    this.bind[i].innerHTML = this.flags[i] ? newVal : this.data[key];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    document.addEventListener(&apos;keyup&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">    document.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class="line">        this.digest();</span><br><span class="line">    &#125;, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//监听函数</span><br><span class="line">watch(watchFn, callback) &#123;</span><br><span class="line">    this.watchers.push(&#123;</span><br><span class="line">        watchFn: watchFn,</span><br><span class="line">        callback: callback || function() &#123;&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//更新数据</span><br><span class="line">digest() &#123;</span><br><span class="line">    let dirty;</span><br><span class="line">    do &#123;</span><br><span class="line">        dirty = false;</span><br><span class="line"></span><br><span class="line">    for (let i = 0, len = this.watchers.length; i &lt; len; i++) &#123;</span><br><span class="line">        let newVal = this.watchers[i].watchFn();</span><br><span class="line">        let oldVal = this.watchers[i].last;</span><br><span class="line"></span><br><span class="line">        if (newVal !== oldVal) &#123;</span><br><span class="line">            this.watchers[i].callback(newVal, oldVal);</span><br><span class="line">            dirty = true;</span><br><span class="line">            this.watchers[i].last = newVal;</span><br><span class="line">            this.flags[i] = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; while(dirty);</span><br></pre></td></tr></table></figure><p><code>watch</code>接受两个参数（这里只考虑了单值的情况，用<code>ng-bind</code>来绑定值），监听的数据与监听的回调函数。digest函数只会在指定事件触发后，才执行，比如这里input框    ,改变输入的值会触发keyup事件，调用<code>digest</code>函数，这个函数会遍历所有的<code>watchers</code>，对比以前的值和新值是否一样，如果不一样就执行回调函数更新数据和视图。<br>我自己实现的版本很基础也很片面，我们可以看看angularjs源码对这部分的描述（这里看angularjs 1.3.20版本）：</p><h3 id="parse"><a href="#parse" class="headerlink" title="$parse"></a>$parse</h3><p><code>parse</code>是一个解析函数，angularjs中单独在一个名叫parse.js的文件中。我们从<code>$get</code>方法出发，它最后会返回一个<code>$parse</code>函数，这个函数的核心部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var lexer = new Lexer(parseOptions);</span><br><span class="line">var parser = new Parser(lexer, $filter, parseOptions);</span><br><span class="line">parsedExpression = parser.parse(exp);</span><br></pre></td></tr></table></figure><p>其中，<code>Lexer</code>这个构造函数中的<code>lex</code>方法用于解析传入数据的所有特殊情况，比如当我检测到这个监控数据为带有引号的字符串时（检查到第一个字符为单引号或者双引号），readString方法就会继续解析后面的字符，最后将结果存到this.tokens中，同理，当检测到是number类型的便会执行readNumber方法，将结果存在this.tokens中。<code>parse</code>就是处理<code>lexer</code>实例返回的this.tokens值，生成执行表达式，其实就是返回一个执行函数。因为这个函数中对四则运算也做了处理，所以当输入1+2的表达式时，最终会返回结果3。  </p><h3 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$watch: function(watchExp, listener, objectEquality) &#123;</span><br><span class="line">    var get = $parse(watchExp);</span><br><span class="line"></span><br><span class="line">    if (get.$$watchDelegate) &#123;</span><br><span class="line">      return get.$$watchDelegate(this, listener, objectEquality, get);</span><br><span class="line">    &#125;</span><br><span class="line">    var scope = this,</span><br><span class="line">        array = scope.$$watchers,</span><br><span class="line">        watcher = &#123;</span><br><span class="line">          fn: listener,</span><br><span class="line">          last: initWatchVal,</span><br><span class="line">          get: get,</span><br><span class="line">          exp: watchExp,</span><br><span class="line">          eq: !!objectEquality</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">    if (!isFunction(listener)) &#123;</span><br><span class="line">      watcher.fn = noop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!array) &#123;</span><br><span class="line">      array = scope.$$watchers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    // we use unshift since we use a while loop in $digest for speed.</span><br><span class="line">    // the while loop reads in reverse order.</span><br><span class="line">    array.unshift(watcher);</span><br><span class="line"></span><br><span class="line">    return function deregisterWatch() &#123;</span><br><span class="line">      arrayRemove(array, watcher);</span><br><span class="line">      lastDirtyWatch = null;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>$watch</code>主要接收三个参数:监听的数据，监听的回调函数，是否深度监听。  </p><ul><li>watch参数：  </li><li>fn：监听函数，当新旧值不想等的时候会执行  </li><li>last：存放旧值  </li><li>get：保存监控表达式对应的函数，主要用来获取表达式的值做新旧值的对比  </li><li>exp：原始监控表达式  </li><li>eq：是否深度比较，存储的是<code>$watch</code>的第三个参数  </li></ul><p>当需要监听数据的时候，<code>get.$$watchDelegate</code>是否存在取决于<code>parse</code>中的parsedExpression.constant的值，而它的值取决于<code>$watch</code>监听的数据是否为常量，如果是常量的话，这个监听函数只会执行一次，不会被push进<code>$$watchers</code>的队列中，如果监听的是变量，那么这个<code>watch</code>会被push到<code>$$watchers</code>队列的最前面。最后会返回一个函数，这个函数的功能就是删除当前的<code>watch</code>，所以如果我们想取消这个监听，可以用一个变量接收<code>$watch</code>的返回值，再执行这个函数就达到了效果。</p><h3 id="evalAsync"><a href="#evalAsync" class="headerlink" title="$evalAsync"></a>$evalAsync</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$evalAsync: function(expr, locals) &#123;</span><br><span class="line">// if we are outside of an $digest loop and this is the first time we are scheduling async</span><br><span class="line">// task also schedule async auto-flush</span><br><span class="line">if (!$rootScope.$$phase &amp;&amp; !asyncQueue.length) &#123;</span><br><span class="line">  $browser.defer(function() &#123;</span><br><span class="line">    if (asyncQueue.length) &#123;</span><br><span class="line">      $rootScope.$digest();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncQueue.push(&#123;scope: this, expression: expr, locals: locals&#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>$evalAsync</code>函数的作用是延迟执行表达式，<code>$$asyncQueue</code>是一个异步的队列，保存着所有需要异步执行的表达式。<code>$bowser.defer</code>是用setTimeout来实现的。</p><h3 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">$digest: function() &#123;</span><br><span class="line">       var watch, value, last,</span><br><span class="line">           watchers,</span><br><span class="line">           length,</span><br><span class="line">           dirty, ttl = TTL,</span><br><span class="line">           next, current, target = this,</span><br><span class="line">           watchLog = [],</span><br><span class="line">           logIdx, logMsg, asyncTask;</span><br><span class="line"></span><br><span class="line">       beginPhase(&apos;$digest&apos;);</span><br><span class="line">       // Check for changes to browser url that happened in sync before the call to $digest</span><br><span class="line">       $browser.$$checkUrlChange();</span><br><span class="line"></span><br><span class="line">       if (this === $rootScope &amp;&amp; applyAsyncId !== null) &#123;</span><br><span class="line">         // If this is the root scope, and $applyAsync has scheduled a deferred $apply(), then</span><br><span class="line">         // cancel the scheduled $apply and flush the queue of expressions to be evaluated.</span><br><span class="line">         $browser.defer.cancel(applyAsyncId);</span><br><span class="line">         flushApplyAsync();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       lastDirtyWatch = null;</span><br><span class="line"></span><br><span class="line">       do &#123; // &quot;while dirty&quot; loop</span><br><span class="line">         dirty = false;</span><br><span class="line">         current = target;</span><br><span class="line"></span><br><span class="line">         while (asyncQueue.length) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">             asyncTask = asyncQueue.shift();</span><br><span class="line">             asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);</span><br><span class="line">           &#125; catch (e) &#123;</span><br><span class="line">             $exceptionHandler(e);</span><br><span class="line">           &#125;</span><br><span class="line">           lastDirtyWatch = null;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         traverseScopesLoop:</span><br><span class="line">          do &#123; // &quot;traverse the scopes&quot; loop</span><br><span class="line">           if ((watchers = current.$$watchers)) &#123;</span><br><span class="line">             // process our watches</span><br><span class="line">             length = watchers.length;</span><br><span class="line">             while (length--) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                 watch = watchers[length];</span><br><span class="line">                 // Most common watches are on primitives, in which case we can short</span><br><span class="line">                 // circuit it with === operator, only when === fails do we use .equals</span><br><span class="line">                 if (watch) &#123;</span><br><span class="line">                   if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;</span><br><span class="line">                       !(watch.eq</span><br><span class="line">                           ? equals(value, last)</span><br><span class="line">                           : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">                              &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) &#123;</span><br><span class="line">                     dirty = true;</span><br><span class="line">                     lastDirtyWatch = watch;</span><br><span class="line">                     watch.last = watch.eq ? copy(value, null) : value;</span><br><span class="line">                     watch.fn(value, ((last === initWatchVal) ? value : last), current);</span><br><span class="line">                     if (ttl &lt; 5) &#123;</span><br><span class="line">                       logIdx = 4 - ttl;</span><br><span class="line">                       if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">                       watchLog[logIdx].push(&#123;</span><br><span class="line">                         msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">                         newVal: value,</span><br><span class="line">                         oldVal: last</span><br><span class="line">                       &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">                     // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">                     // have already been tested.</span><br><span class="line">                     dirty = false;</span><br><span class="line">                     break traverseScopesLoop;</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125; catch (e) &#123;</span><br><span class="line">                 $exceptionHandler(e);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">            // Insanity Warning: scope depth-first traversal</span><br><span class="line">           // yes, this code is a bit crazy, but it works and we have tests to prove it!</span><br><span class="line">           // this piece should be kept in sync with the traversal in $broadcast</span><br><span class="line">           if (!(next = (current.$$childHead ||</span><br><span class="line">               (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">             while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">               current = current.$parent;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125; while ((current = next));</span><br><span class="line"></span><br><span class="line">         // `break traverseScopesLoop;` takes us to here</span><br><span class="line"></span><br><span class="line">         if ((dirty || asyncQueue.length) &amp;&amp; !(ttl--)) &#123;</span><br><span class="line">           clearPhase();</span><br><span class="line">           throw $rootScopeMinErr(&apos;infdig&apos;,</span><br><span class="line">               &apos;&#123;0&#125; $digest() iterations reached. Aborting!\n&apos; +</span><br><span class="line">               &apos;Watchers fired in the last 5 iterations: &#123;1&#125;&apos;,</span><br><span class="line">               TTL, watchLog);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       &#125; while (dirty || asyncQueue.length);</span><br><span class="line"></span><br><span class="line">       clearPhase();</span><br><span class="line"></span><br><span class="line">       while (postDigestQueue.length) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">           postDigestQueue.shift()();</span><br><span class="line">         &#125; catch (e) &#123;</span><br><span class="line">           $exceptionHandler(e);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br></pre></td></tr></table></figure><p><code>asyncQueue</code>代表异步队列，这里有两层循环，外层循环是为了保证所有的model都能被检测到，循环的两个条件，一是asyncQueue.length不为空；二是dirty为true,在监控watch的值的变化时，会将dirty置为true，循环开始会执行<code>asyncQueue</code>队列中的表达式。</p><p>内层循环用来遍历所有的watch函数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(value = watch.get(current)) !== (last = watch.last) &amp;&amp;  </span><br><span class="line">!(watch.eq</span><br><span class="line">    ? equals(value, last)</span><br><span class="line">    : (typeof value === &apos;number&apos; &amp;&amp; typeof last === &apos;number&apos;</span><br><span class="line">       &amp;&amp; isNaN(value) &amp;&amp; isNaN(last))))</span><br></pre></td></tr></table></figure><p>判断新值和旧值是否发生了变化，并且用watch.eq判断是否为深度监听，<code>equals</code>函数用来比较两个值是否相等，这个函数把所有可能的情况都考虑了进去，以前自己实现过两个值的比较，但是对于像DateRegExp这种类型的值的比较是没有考虑的，也正好查漏补缺。<br>内层循环的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) &#123;</span><br><span class="line">  while (current !== target &amp;&amp; !(next = current.$$nextSibling)) &#123;</span><br><span class="line">    current = current.$parent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码表示，在当前作用域下执行完对watch的监控之后，还要继续查找它的子作用域，兄弟作用域，父作用域，如果next有值就会一直循环，直到这一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if (ttl &lt; 5) &#123;</span><br><span class="line">    logIdx = 4 - ttl;</span><br><span class="line">    if (!watchLog[logIdx]) watchLog[logIdx] = [];</span><br><span class="line">    watchLog[logIdx].push(&#123;</span><br><span class="line">      msg: isFunction(watch.exp) ? &apos;fn: &apos; + (watch.exp.name || watch.exp.toString()) : watch.exp,</span><br><span class="line">      newVal: value,</span><br><span class="line">      oldVal: last</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (watch === lastDirtyWatch) &#123;</span><br><span class="line">  // If the most recently dirty watcher is now clean, short circuit since the remaining watchers</span><br><span class="line">  // have already been tested.</span><br><span class="line">  dirty = false;</span><br><span class="line">  break traverseScopesLoop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的ttl的初始值为10（默认值），ttl的存在就是为了防止循环次数过多，如果超过最大次数，就会throw错误并告诉开发者循环可能永远不会稳定。当ttl小于5的时候开始记录<code>watchLog</code>对象，如果当前的watch与最后一次检查的<code>lastDirtyWatch</code>相等的话就跳出内层循环同时结束外层循环。最后会执行<code>postDigestQueue</code>队列中的函数，这个跟asyncQueue不同的是，它不会主动触发<code>digest</code>方法,只是往<code>postDigestQueue</code>队列中增加执行表达式，在<code>digest</code>内最后执行。</p><p>通过阅读angularjs脏值检测的源码部分，对它底层的实现有了大致的了解，对于parse.js可以作为一个字符串的解析器，实际场景比如实现一个计算器，equals函数用来比较两个值是否相等，都是值得借鉴的部分。与之前实现的简易版本比较，实际angularjs框架做的东西就多得多了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;angularjs的双向数据绑定原理及简单的实现。&lt;/p&gt;
    
    </summary>
    
      <category term="yangxiaotong" scheme="http://xgfe.github.io/categories/yangxiaotong/"/>
    
    
      <category term="angularjs" scheme="http://xgfe.github.io/tags/angularjs/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 源码学习</title>
    <link href="http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/"/>
    <id>http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/</id>
    <published>2018-07-11T04:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.378Z</updated>
    
    <content type="html"><![CDATA[<p>dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。<br><a id="more"></a></p><p>📚<a href="https://github.com/iamkun/dayjs/blob/master/docs/zh-cn/API-reference.md" target="_blank" rel="noopener">官方 API 文档（中文）</a></p><h2 id="一-特性"><a href="#一-特性" class="headerlink" title="一 特性"></a>一 特性</h2><ul><li>和 Moment.js 相同的 API 和用法</li><li>不可变数据（Immutable）</li><li>支持链式操作（Chainable）</li><li>l18n 国际化</li><li>仅 2kb 大小</li><li>全浏览器兼容</li></ul><p>基本用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(<span class="string">'month'</span>).add(<span class="number">1</span>, <span class="string">'day'</span>).set(<span class="string">'year'</span>, <span class="number">2018</span>).format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="二-解析"><a href="#二-解析" class="headerlink" title="二 解析"></a>二 解析</h2><h3 id="构造器-dayjs-existing-string-number-Date-Dayjs"><a href="#构造器-dayjs-existing-string-number-Date-Dayjs" class="headerlink" title="构造器 dayjs(existing?: string | number | Date | Dayjs)"></a>构造器 dayjs(existing?: string | number | Date | Dayjs)</h3><p>从源码可以看出，调用 dayjs 时会返回一个 Dayjs 对象，Dayjs 构造器调用了 parseDate 方法，返回了一个全新的包含 Javascript Date 对象的 Dayjs 的对象；其他的值都是根据 Javascript Date 对象得来的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="function">(<span class="params">date, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDayjs(date)) &#123;</span><br><span class="line">    <span class="keyword">return</span> date.clone()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cfg = c || &#123;&#125;</span><br><span class="line">  cfg.date = date</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dayjs(cfg) <span class="comment">// eslint-disable-line no-use-before-define</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parseDate = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg</span><br><span class="line">  <span class="keyword">if</span> (date === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="literal">NaN</span>) <span class="comment">// Treat null as an invalid date</span></span><br><span class="line">  <span class="keyword">if</span> (Utils.isUndefined(date)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> date</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> date === <span class="string">'string'</span>)</span><br><span class="line">    &amp;&amp; (<span class="regexp">/.*[^Z]$/i</span>.test(date)) <span class="comment">// looking for a better way</span></span><br><span class="line">    &amp;&amp; (reg = date.match(C.REGEX_PARSE))) &#123;</span><br><span class="line">    <span class="comment">// 2018-08-08 or 20180808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(</span><br><span class="line">      reg[<span class="number">1</span>], reg[<span class="number">2</span>] - <span class="number">1</span>, reg[<span class="number">3</span>] || <span class="number">1</span>,</span><br><span class="line">      reg[<span class="number">5</span>] || <span class="number">0</span>, reg[<span class="number">6</span>] || <span class="number">0</span>, reg[<span class="number">7</span>] || <span class="number">0</span>, reg[<span class="number">8</span>] || <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date) <span class="comment">// timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dayjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(cfg) <span class="comment">// for plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">  parse(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$d = parseDate(cfg.date)</span><br><span class="line">    <span class="keyword">this</span>.init(cfg)</span><br><span class="line">  &#125;</span><br><span class="line">  init(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$y = <span class="keyword">this</span>.$d.getFullYear()</span><br><span class="line">    <span class="keyword">this</span>.$M = <span class="keyword">this</span>.$d.getMonth()</span><br><span class="line">    <span class="keyword">this</span>.$D = <span class="keyword">this</span>.$d.getDate()</span><br><span class="line">    <span class="keyword">this</span>.$W = <span class="keyword">this</span>.$d.getDay()</span><br><span class="line">    <span class="keyword">this</span>.$H = <span class="keyword">this</span>.$d.getHours()</span><br><span class="line">    <span class="keyword">this</span>.$m = <span class="keyword">this</span>.$d.getMinutes()</span><br><span class="line">    <span class="keyword">this</span>.$s = <span class="keyword">this</span>.$d.getSeconds()</span><br><span class="line">    <span class="keyword">this</span>.$ms = <span class="keyword">this</span>.$d.getMilliseconds()</span><br><span class="line">    <span class="keyword">this</span>.$L = <span class="keyword">this</span>.$L || parseLocale(cfg.locale, <span class="literal">null</span>, <span class="literal">true</span>) || L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 init 实例方法中，使用实例属性 $d（为 JavaScript 原生 Date 对象）来获取 年、月、日、周、时、分、秒、毫秒，且保存在实例中。并且调用 parseLocale 函数来获取语言，赋值给 Dayjs 实例的 $L 属性。</p><p>可传参数有5类：  </p><h5 id="1-当前时间"><a href="#1-当前时间" class="headerlink" title="1.当前时间"></a>1.当前时间</h5><p>dayjs 本质上是个函数，因此可以直接运行该函数，得到包含当前时间和日期的 Dayjs 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs();</span><br></pre></td></tr></table></figure></p><h5 id="2-标准的-ISO-8601-时间字符串"><a href="#2-标准的-ISO-8601-时间字符串" class="headerlink" title="2.标准的 ISO 8601 时间字符串"></a>2.标准的 ISO 8601 时间字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="string">"2018-07-14"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-解析-Unix-时间戳-毫秒"><a href="#3-解析-Unix-时间戳-毫秒" class="headerlink" title="3.解析 Unix 时间戳(毫秒)"></a>3.解析 Unix 时间戳(毫秒)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="number">1531469940578</span>);</span><br></pre></td></tr></table></figure><h5 id="4-解析-Date-对象"><a href="#4-解析-Date-对象" class="headerlink" title="4.解析 Date 对象"></a>4.解析 Date 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h5 id="5-解析-dayjs-对象"><a href="#5-解析-dayjs-对象" class="headerlink" title="5.解析 dayjs 对象"></a>5.解析 dayjs 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(dayjs());</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>dayjs 对象是不可变的如果要复制对象，需要调用 .clone()，或者是在解析一个 dayjs 对象。 向 dayjs() 里传入一个 Dayjs 对象也能实现同样的效果。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().clone();</span><br><span class="line">dayjs(Dayjs);</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function">(<span class="params">date, instance</span>) =&gt;</span> dayjs(date, &#123; <span class="attr">locale</span>: instance.$L &#125;)</span><br><span class="line">clone() &#123;</span><br><span class="line">  <span class="keyword">return</span> wrapper(<span class="keyword">this</span>.toDate(), <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>检测当前 Dayjs 对象是否是一个有效的时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().isValid();</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isValid() &#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="keyword">this</span>.$d.toString() === <span class="string">'Invalid Date'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三-获取-设置"><a href="#三-获取-设置" class="headerlink" title="三 获取+设置"></a>三 获取+设置</h2><h5 id="获取各种时间"><a href="#获取各种时间" class="headerlink" title="获取各种时间"></a>获取各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dayjs().year();        <span class="comment">// 年</span></span><br><span class="line">dayjs().month();       <span class="comment">// 月</span></span><br><span class="line">dayjs().date();        <span class="comment">// 日</span></span><br><span class="line">dayjs().day();         <span class="comment">// 星期(星期天 0, 星期六 6)</span></span><br><span class="line">dayjs().hour();        <span class="comment">// 时</span></span><br><span class="line">dayjs().minute();      <span class="comment">// 分</span></span><br><span class="line">dayjs().second();      <span class="comment">// 秒</span></span><br><span class="line">dayjs().millisecond(); <span class="comment">// 毫秒</span></span><br></pre></td></tr></table></figure><h5 id="设置各种时间"><a href="#设置各种时间" class="headerlink" title="设置各种时间"></a>设置各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().set(unit : <span class="built_in">String</span>, <span class="attr">value</span> : Int);</span><br><span class="line">dayjs().set(<span class="string">'date'</span>, <span class="number">1</span>);</span><br><span class="line">dayjs().set(<span class="string">'month'</span>, <span class="number">3</span>); <span class="comment">// 四月</span></span><br><span class="line">dayjs().set(<span class="string">'second'</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>设置时间也是通过返回一个新的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(string, int) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clone().$set(string, int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四-格式化显示"><a href="#四-格式化显示" class="headerlink" title="四 格式化显示"></a>四 格式化显示</h2><p>格式化显示和 momentjs 一样，通过 .format() 即可，返回的是 String 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().format(<span class="built_in">String</span>);</span><br><span class="line">dayjs().format();             <span class="comment">// "2018-07-13T20:10:31+08:00"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// "2018-07-13"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY/MM/DD'</span>); <span class="comment">// "2018/07/13"</span></span><br></pre></td></tr></table></figure></p><h2 id="五-操作"><a href="#五-操作" class="headerlink" title="五 操作"></a>五 操作</h2><h5 id="增加和减少"><a href="#增加和减少" class="headerlink" title="增加和减少"></a>增加和减少</h5><p>在此之前先看看源码实现的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 部分源码</span></span><br><span class="line">add(number, units) &#123;</span><br><span class="line">  number = <span class="built_in">Number</span>(number) <span class="comment">// eslint-disable-line no-param-reassign</span></span><br><span class="line">  <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">  <span class="keyword">const</span> instanceFactory = <span class="function">(<span class="params">u, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">this</span>.set(C.DATE, <span class="number">1</span>).set(u, n + number)</span><br><span class="line">    <span class="keyword">return</span> date.set(C.DATE, <span class="built_in">Math</span>.min(<span class="keyword">this</span>.$D, date.daysInMonth()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.M) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.M, <span class="keyword">this</span>.$M)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.Y) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.Y, <span class="keyword">this</span>.$y)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> step</span><br><span class="line">  <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">    <span class="keyword">case</span> C.MIN:</span><br><span class="line">      step = C.MILLISECONDS_A_MINUTE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.H:</span><br><span class="line">      step = C.MILLISECONDS_A_HOUR</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.D:</span><br><span class="line">      step = C.MILLISECONDS_A_DAY</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.W:</span><br><span class="line">      step = C.MILLISECONDS_A_WEEK</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.S:</span><br><span class="line">      step = C.MILLISECONDS_A_SECOND</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// ms</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextTimeStamp = <span class="keyword">this</span>.valueOf() + (number * step)</span><br><span class="line">  <span class="keyword">return</span> wrapper(nextTimeStamp, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">subtract(number, string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.add(number * <span class="number">-1</span>, string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dayjs 类中 add、subtract 等方法，都会通过 wrapper 返回一个新的 Dayjs 实例，是通过使用 Dayjs 类中的 clone() 方法实现的。所以，通过这个 clone() 方法，实现了 dayjs 的 immutable 特性。<br>当增加或减少的单位是年或月时，会先将日设置为1，然后再加减，最后再比较当前月的总天数和原来的天数（主要是解决像2月只有28天这类问题），取较小的值再返回；对于天／周／时／分／秒则是按照时间戳来计算，再通过 wrapper 返回一个新的 Date 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().add(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().add(<span class="number">5</span>, <span class="string">'day'</span>);</span><br><span class="line">dayjs().subtract(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().subtract(<span class="number">2</span>, <span class="string">'year'</span>);</span><br></pre></td></tr></table></figure></p><h5 id="开头和末尾"><a href="#开头和末尾" class="headerlink" title="开头和末尾"></a>开头和末尾</h5><p>返回当前时间的开头时间的 Dayjs 对象，如月份的第一天。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().startOf(<span class="string">'year'</span>).format(<span class="string">'YYYY-MM-DD'</span>);  <span class="comment">// 2018-01-01</span></span><br></pre></td></tr></table></figure></p><p>返回当前时间的末尾时间的 Dayjs 对象，如月份的最后一天。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().endOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().endOf(<span class="string">'month'</span>).format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// 2018-07-31</span></span><br></pre></td></tr></table></figure><h2 id="六-时间差"><a href="#六-时间差" class="headerlink" title="六 时间差"></a>六 时间差</h2><p>时间差是两个 dayjs 对象的之差所得的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().diff(Dayjs, unit);</span><br><span class="line">dayjs().diff(dayjs(<span class="string">'2000-2-1'</span>), <span class="string">'years'</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p><p>源码逻辑是先计算出两个时间相差的毫秒数和月数，再根据传入的单位去选择计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff(input, units, float) &#123;</span><br><span class="line">    <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">    <span class="keyword">const</span> that = dayjs(input)</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="keyword">this</span> - that</span><br><span class="line">    <span class="keyword">let</span> result = Utils.monthDiff(<span class="keyword">this</span>, that)</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">      <span class="keyword">case</span> C.Y:</span><br><span class="line">        result /= <span class="number">12</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.M:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.Q:</span><br><span class="line">        result /= <span class="number">3</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.W:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_WEEK</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.D:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_DAY</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.H:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_HOUR</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.MIN:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_MINUTE</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.S:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_SECOND</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// milliseconds</span></span><br><span class="line">        result = diff</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> float ? result : Utils.absFloor(result)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="七-其他方法"><a href="#七-其他方法" class="headerlink" title="七 其他方法"></a>七 其他方法</h2><h5 id="获取-unix-毫秒时间戳："><a href="#获取-unix-毫秒时间戳：" class="headerlink" title="获取 unix 毫秒时间戳："></a>获取 unix 毫秒时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().valueOf(); <span class="comment">// 1531633650522</span></span><br></pre></td></tr></table></figure><h5 id="获取-unix-秒级时间戳："><a href="#获取-unix-秒级时间戳：" class="headerlink" title="获取 unix 秒级时间戳："></a>获取 unix 秒级时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().unix(); <span class="comment">// 1531633677</span></span><br></pre></td></tr></table></figure><h5 id="返回月份的天数："><a href="#返回月份的天数：" class="headerlink" title="返回月份的天数："></a>返回月份的天数：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().daysInMonth(); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h5 id="获取-Date-对象："><a href="#获取-Date-对象：" class="headerlink" title="获取 Date 对象："></a>获取 Date 对象：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toDate(); <span class="comment">// Sun Jul 15 2018 13:48:41 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure><h5 id="获取数组格式："><a href="#获取数组格式：" class="headerlink" title="获取数组格式："></a>获取数组格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toArray(); <span class="comment">//[2018, 6, 13, 20, 34, 13, 424];</span></span><br></pre></td></tr></table></figure><h5 id="获取对象格式："><a href="#获取对象格式：" class="headerlink" title="获取对象格式："></a>获取对象格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toObject();<span class="comment">// &#123;years: 2018, months: 6, date: 13, hours: 20, minutes: 34...&#125;</span></span><br></pre></td></tr></table></figure><h2 id="八-dayjs-插件用法"><a href="#八-dayjs-插件用法" class="headerlink" title="八 dayjs 插件用法"></a>八 dayjs 插件用法</h2><p>dayjs 的插件，通过挂载到 dayjs 函数下的 extend 函数加载，然后使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plugin <span class="comment">// 导入插件</span></span><br><span class="line">dayjs.extend(plugin, options) <span class="comment">// 加载插件的同时，加入插件所需要的参数</span></span><br></pre></td></tr></table></figure></p><p>使用官方的 IsLeapYear 插件(判断是否是闰年):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isLeapYear <span class="keyword">from</span> <span class="string">'dayjs/plugin/isLeapYear'</span></span><br><span class="line">dayjs.extend(isLeapYear)</span><br><span class="line">dayjs(<span class="string">'2000-01-01'</span>).isLeapYear() <span class="comment">// true</span></span><br><span class="line">dayjs(<span class="string">'2018-01-01'</span>).isLeapYear() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>dayjs.extend() 方法，接受两个参数，即插件（函数）和插件的选项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展插件的方法</span></span><br><span class="line"><span class="comment">// plugin：插件函数</span></span><br><span class="line"><span class="comment">// option：插件的选项</span></span><br><span class="line">dayjs.extend = <span class="function">(<span class="params">plugin, option</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 插件函数接受三个参数</span></span><br><span class="line">  <span class="comment">// 1.插件选项 2.Dayjs 类 3.dayjs 函数</span></span><br><span class="line">  <span class="comment">// 插件的方法都是挂载在 Dayjs 类的原型对象上的（Dayjs.prototype）。</span></span><br><span class="line">  plugin(option, Dayjs, dayjs)</span><br><span class="line">  <span class="keyword">return</span> dayjs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IsLeapYear 的源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (o, c) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> proto = c.prototype</span><br><span class="line">  proto.isLeapYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.$y % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.$y % <span class="number">100</span> !== <span class="number">0</span>)) || (<span class="keyword">this</span>.$y % <span class="number">400</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 isLeapYear 函数挂载到 Dayjs 类的原型上，所以每个 Dayjs 实例都可以使用 isLeapYear 方法。</p><hr><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p> 特别感谢 DaisyXL 和 Young 的支持和分析！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="dayjs" scheme="http://xgfe.github.io/tags/dayjs/"/>
    
      <category term="momentjs" scheme="http://xgfe.github.io/tags/momentjs/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端安全科普之 XSS</title>
    <link href="http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/"/>
    <id>http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/</id>
    <published>2018-06-13T03:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.397Z</updated>
    
    <content type="html"><![CDATA[<p>Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。</p><p>XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。</p><p>在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。</p><a id="more"></a><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>跨站脚本的重点在脚本上，绝大多数的 XSS 会采用一段远程或者第三方域上的脚本资源，这样做的好处是攻击代码容易控制。script 标签可以嵌入第三方资源，这是浏览器允许的，对于嵌入的脚本内容，会与本域的脚本内容一样，在整个脚本上下文环境中存在，那么在这个场景中的各种功能都可以由嵌入的脚本实现，也就是说 JavaScript 能做到什么效果，XSS 的威力就有多大。</p><p>JavaScript 可以用用来获取的 Cookie、改变网页内容、URL 跳转，那么存在 XSS 漏洞的网站，就可以盗取用户 Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向 Web 页面中注入 JavaScript 代码。</p><p>XSS 攻击原理主要包括三个部分：</p><ul><li><p>攻击者对某含有漏洞的服务器发起 XSS 攻击（注入 JS 代码）。</p></li><li><p>诱使受害者打开受到攻击的服务器 URL（邮件、留言等，此步骤可选项）。</p></li><li><p>受害者在 Web 浏览器中打开 URL，恶意脚本执行。</p></li></ul><p>XSS 构造的例子：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入内容直接拼接到返回 HTML 里</span><br><span class="line">res.body = &apos;...&lt;div&gt;&apos; + data.用户输入的内容 + &apos;&lt;/div&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入的内容直接拼接到了页面元素的属性中</span><br><span class="line">res.body = &apos;...&lt;img src=&quot; + data.用户输入的图片地址 + &quot;&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&quot; /&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面中</span><br><span class="line">div.innerHTML = data.用户输入的内容</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，innerHTML 中的 script 标签不会被执行，但是攻击者可以这么写：</span><br><span class="line">&lt;img src=&quot;x.png&quot; onload=&quot;alert(123)&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面元素的属性中</span><br><span class="line">a.href = data.用户输入的链接</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，给元素的属性赋值时内容总会被当成字符串，但是攻击者可以这么写，如用户点了链接就会受到攻击：</span><br><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure></code></pre><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><p>XSS 有三种类型，分别是反射型 XSS、存储型 XSS、DOM XSS，下面分别对这三种 XSS 进行介绍。</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 也被称为非持久性 XSS，是最容易出现的一种 XSS 漏洞，指的是发送请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后被浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。它的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">&lt;?php</span><br><span class="line">    echo $_GET[&apos;x&apos;];</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">// 在浏览器地址栏中输入</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/a7271f75b155dbab2e0c3fb758cbe111100565.png" alt="反射型XSS"></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 又被称为永久性 XSS，是最危险的一种跨站脚本，指的是发送请求时，提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统），下次请求目标页面时不用再提交 XSS 代码，存储型 XSS 的攻击是最隐蔽的，其危害性也更大。与反射型 XSS 和 DOM XSS 相比，存储型 XSS 的执行不需要手动触发。最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。它的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>DOM XSS 指的是 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。它的数据流向是：URL-&gt;浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 客户端的脚本</span><br><span class="line">&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 用户点击这个 URL# 后的内容不会发送到服务端，仅在客户端被接收并解释执行。</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/919bcf853c27bbd16656cfa83b8b6ef887889.png" alt="DOM XSS"></p><h4 id="DOM-XSS-场景一：在前端实现页面跳转"><a href="#DOM-XSS-场景一：在前端实现页面跳转" class="headerlink" title="DOM XSS 场景一：在前端实现页面跳转"></a>DOM XSS 场景一：在前端实现页面跳转</h4><p>在前端实现页面跳转，前端通常会通过 JavaScript 实现跳转，最常用到的方法有: location.href / location.replace() / location.assign()。 在该场景下，可以通过伪协议“javascript:”、“data:”在浏览器下执行脚本。但是这种通过伪协议进行攻击已经随着前端工程处理对相关跳转代码逻辑做了很好的完善，基本上不会再出现上述的这种情况。但是如下两种情况却为 Web 攻击打开了天窗：</p><ul><li><p>使用 indexOf 判断 URL 参数是否合法，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。所以如果 URL 中包含了伪代码及攻击代码，就会被攻击。</p></li><li><p>正则表达式判断 URL 是否合法，为了避免使用 indexOf 判断 URL 带来的缺陷，有些开发人员会想到用正则表达式，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别，如果没有加“^”，攻击者仍然可以绕过正则的过滤，在URL中植入伪代码和攻击代码。</p></li><li><p>修复方案：在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是 http、https 或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 </p></li></ul><h4 id="DOM-XSS-场景二：取值写入页面或动态执行"><a href="#DOM-XSS-场景二：取值写入页面或动态执行" class="headerlink" title="DOM XSS 场景二：取值写入页面或动态执行"></a>DOM XSS 场景二：取值写入页面或动态执行</h4><p>除接收 URL 参数经后端处理最后在前端展示外，在 Web 前端通过 JavaScript 获取不同来源的参数值，不经后端处理即刻在 Web 页面进行展示或动态执行的业务场景也十分常见，想要在客户端实现接受参数并写入页面或动态执行，就不得不用到 innerHTML、document.write、eval。因为 JavaScript 取值的来源纷繁复杂，如果忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给 JavaScriptinnerHTML、document.write、eval处理，就有可能招来 DOM-XSS。下面是三种常见的缺陷： </p><ul><li><p>从 URL 中的取参数值写入页面或动态执行，如直接从 URL 的锚参数（即位于#后面的参数）中取值，不经过任何处理直接 innerHTML 写入页面，导致攻击者只需要构造如下URL即可完成一次 DOM XSS 攻击。由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型 XSS 的 Web 应用防火墙（WAF），这类 DOM XSS 也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 </p></li><li><p>从 Cookie 中的取参数值写入页面或动态执行，原理基本同从 URL 中的取参数值写入页面或动态执行，只是换了一个取值来源而已。</p></li><li><p>从 LocalStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 ，如取 window.name 的值，最后直接 innerHTML 到页面中。一般情况下，页面的 window.name 攻击者不可控，故往往会被认为来源相对可信。但借助i frame 的 name 属性，攻击者可以将页面的 window.name 设置为攻击代码，仍然可以构造 DOM XSS。</p></li><li><p>修复方案：</p><ul><li><p>写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的 HTML 特殊字符进行转义处理能防止大部分 DOM-XSS 的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 </p></li><li><p>慎用危险的“eval”。需要强调的是，由于 JavaScript 中的 eval 函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用 eval<br>函数处理不可控的外部数据。 </p></li><li><p>编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从 Cookie，还是从LocalStorage、Referer、Window name、SessionStorage 中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 </p></li></ul></li></ul><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li><p>盗取用户的 Cookie，Cookie 经常被用来存储用户的会话信息，比如用户登录认证后的 session，之后同域内发出的请求都会自动带上认证后的会话信息。如果 Cookie被盗取，攻击者就可以不用通过密码而直接登录用户的账户。Cookie 的重要字段：[name] [value] [domain] [path] [expires] [httponly] [secure]，其含义依次是：名称、值、所属域名、所属相对根路径、过期时间、是否有 HttpOnly 标志、是否有 Secure 标志。如果设置了 HttpOnly 标志，客户端脚本就无法通过document.cookie 获取该 Cookie，这样就能有效地防御 XSS 攻击获取 Cookie。</p></li><li><p>构建 GET 和 POST 请求，如果 Cookie 设置了 HttpOnly 标志，则无法直接劫持 Cookie 来使用了，但是 XSS 可以在 JavaScript 中构建 GET 或者 POST 请求，来实现自己的攻击。只要让用户执行下面这段脚本，就能发起 GET 请求，攻击者通过 XSS 诱导用户来执行。XSS 的攻击过程都是在浏览器通过执行 JavaScript 脚本自动进行，缺少与用户交互的过程。例如在 POST 的请求中，如果需要输入验证码，JS 代码无法解析验证码，攻击也就无法实现。但是针对验证码这种情况，如果 XSS 可以通过把验证码的图片发到远端攻击服务器，服务器解析验证码然后把结果返回给 JS 代码，JS 获取后继续进行攻击，不过就是成本有点高。</p></li><li><p>XSS 钓鱼：上面模拟用户的 POST 请求貌似成本有点高，攻击者可以将 XSS 和钓鱼结合在一起，例如通过 JavaScript 代码模拟出网站的登录框，用户输入用户名和密码后，XSS 将这些信息发送到服务器端，用来进行攻击。</p></li><li><p>获取用户系统信息，此外 XSS 还可以识别用户的浏览器信息、用户安装的软件以及用户真实的 IP 等信息。</p></li><li><p>XSS Worm：这是 XSS 的一种终极利用方式，破坏力和影响力是巨大的，与蠕虫病毒一样具有“传染性”，与系统病毒的唯一区别就是无法对系统底层操作。XSS 蠕虫是针对浏览器的攻击，网站规模越大，攻击效果就越大。一般来说，用户直接发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 Worm 攻击。</p></li></ul><h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><ul><li><p>任何由用户输出的数据都是不可信的。</p></li><li><p>不要在奇怪的地方插入不可信的数据。</p><p><img src="http://vfile.meituan.net/xgfe/0a853e1b33a7dfaeb4aa47f12453026b97763.png" alt="不可信数据"></p></li><li><p>进行输入输出检查，将期望被当成字符串的不可信数据转义后再插入文档中，不同位置需要使用不同的转义逻辑。</p><p><img src="http://vfile.meituan.net/xgfe/3df441ed85fa308c54a059924acd16e0248873.png" alt="输入输出检查"></p></li><li><p>将期望被当成 HTML 的不可信数据使用专业的库消毒后再插入文档中。</p></li><li><p>使用 HttpOnly 的 Cookie，给关键的 Cookie 设置 HttpOnly 属性，这样能够避免 JS 读取 Cookie信息，设置后有助于缓解 XSS，但是 XSS 除了劫持 Cookie 之外，还可以模拟用户的身份进行操作。</p></li><li><p>使用内容安全策略（CSP）是对抗 XSS 的深度防御策略，内容安全策略可以以白名单的方式限定哪些地方的内容可以被加载和执行，如果不存在可以通过本地文件放置恶意代码的其他漏洞，则该策略是有效的。</p></li><li><p>使用设计上就会自动编码来解决XSS问题的框架，如：React JS。了解每个框架的 XSS 保护的局限性，并适当地处理未覆盖的用例。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">XSS攻击手册</a></p></li><li><p><a href="https://www.owasp.org/index.php/XSS_Prevention_Cheat_Sheet" target="_blank" rel="noopener">XSS防御手册</a></p></li><li><p>《Web前端黑客技术揭秘》</p></li><li><p>《Web安全深度剖析》</p></li><li><p>《白帽子讲Web安全》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。&lt;/p&gt;
&lt;p&gt;XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。&lt;/p&gt;
&lt;p&gt;CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。&lt;/p&gt;
&lt;p&gt;界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。&lt;/p&gt;
&lt;p&gt;在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpeiyu" scheme="http://xgfe.github.io/categories/wangpeiyu/"/>
    
    
      <category term="XSS" scheme="http://xgfe.github.io/tags/XSS/"/>
    
      <category term="Web 安全" scheme="http://xgfe.github.io/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
      <category term="前端安全" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前后端通信的几种方式</title>
    <link href="http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/"/>
    <id>http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.373Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。</p><a id="more"></a><h2 id="一、前后端通信（同源）简介"><a href="#一、前后端通信（同源）简介" class="headerlink" title="一、前后端通信（同源）简介"></a>一、前后端通信（同源）简介</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>同源策略显示从一个源加载的文档或脚本如何来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。源包含三部分内容（协议，端口和域名，默认端口是 80 ）。<br>同源的限制：<br>（1）Cookie , LocalStorage 和 IndexDB 无法获取<br>（2）DOM无法获得和操作<br>（3）Ajax请求不能发送，只是用与同源通信</p><h3 id="2-前后端通信的几种方式"><a href="#2-前后端通信的几种方式" class="headerlink" title="2.前后端通信的几种方式"></a>2.前后端通信的几种方式</h3><ul><li>Ajax（同源下面的通信方式）</li><li>WebSocket（不受同源策略限制）</li><li>CORS（支持跨域也支持同源）</li></ul><h3 id="3-如何创建一个Ajax"><a href="#3-如何创建一个Ajax" class="headerlink" title="3.如何创建一个Ajax"></a>3.如何创建一个Ajax</h3><p>发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）<br>（1）创建 XMLHttpRequest 对象。<br>（2）使用 open 方法设置请求的参数。open ( method , url, 是否异步)。<br>（3）发送请求。<br>（4）注册事件。 注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>（5）获取返回的数据，更新UI。<br>post 请求举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 建立XMLHttpRequest对象       </span><br><span class="line">var xhr = new XMLHttpRequest();        </span><br><span class="line">xhr.open(&apos;post&apos;, &apos;02.post.php&apos;);           </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">// 将数据通过send方法传递       </span><br><span class="line">xhr.send(&apos;name=fox&amp;age=18&apos;);            </span><br><span class="line">xhr.onreadystatechange = function () &#123;                 </span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; </span><br><span class="line">        //判断返回状态  </span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-实际开发中用的原生Ajax请求"><a href="#4-实际开发中用的原生Ajax请求" class="headerlink" title="4.实际开发中用的原生Ajax请求"></a>4.实际开发中用的原生Ajax请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">var util = &#123;&#125;;      </span><br><span class="line">//获取 Ajax 请求之后的 json     </span><br><span class="line">util.json = function (options) &#123;</span><br><span class="line">    var opt = &#123;</span><br><span class="line">        url: &apos;&apos;,</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    Object.assign(opt, options);</span><br><span class="line">    //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api             </span><br><span class="line">    var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    var data = opt.data,</span><br><span class="line">    var type = opt.type.toUpperCase();</span><br><span class="line">    var dataArr = [];</span><br><span class="line">    if (opt.url) &#123;   </span><br><span class="line">        var url = opt.url;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var key in data) &#123;</span><br><span class="line">        dataArr.push(key + &apos;=&apos; + data[key]);</span><br><span class="line">    &#125; </span><br><span class="line">    if (type === &apos;GET&apos;) &#123;</span><br><span class="line">        url = url + &apos;?&apos; + dataArr.join(&apos;&amp;&apos;);</span><br><span class="line">        xhr.open(type, url.replace(/\?$/g, &apos;&apos;), true);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    if (type === &apos;POST&apos;) &#123;</span><br><span class="line">        xhr.open(type, url, true);</span><br><span class="line">        // 如果想要使用post提交数据,需要明确设置Request Header    </span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.send(dataArr.join(&apos;&amp;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">            //304表示：用缓存即可。206表示获取媒体资源的前面一部分                </span><br><span class="line">            var res;</span><br><span class="line">            if (opt.success &amp;&amp; opt.success instanceof Function) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                if (typeof res === &apos;string&apos;) &#123;</span><br><span class="line">                    //将字符串转成json</span><br><span class="line">                    res = JSON.parse(res);                           </span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (opt.error &amp;&amp; opt.error instanceof Function) &#123;</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-WebSocket-介绍"><a href="#5-WebSocket-介绍" class="headerlink" title="5.WebSocket 介绍"></a>5.WebSocket 介绍</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。所以出现了 WebSocket 。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><p>通常WebSocket协议的链接如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure></p><p>WebSocket 的实现需要后端搭建一个 WebSocket 服务器，但是如果想搭建一个 WebSocket 服务器就没有那么轻松了，因为 WebSocket 是一种新的通信协议，目前还是草案，没有成为标准，比如 PyWebSocket , WebSocket-Node , LibWebSockets 等等，这些库文件已经实现了WebSocket 数据包的封装和解析，我们可以调用这些接口，这在很大程度上减少了我们的工作量。<br>具体的实现方式：（在客户端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 再js文件中 创建WebSocket对象</span><br><span class="line">var ws = new WebSocket(‘wss://echo.WebSocket.org’);</span><br><span class="line">ws.onopen = function (evt) &#123;</span><br><span class="line">    console.log(‘connnection……’);</span><br><span class="line">    ws.send(&apos;hello WebSocket&apos;);</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = function (evt) &#123;</span><br><span class="line">    console.log(&apos;received message&apos; + evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;</span><br><span class="line">ws.onclose = dunction(evt)&#123;</span><br><span class="line">    console.log(&apos;connection closed.&apos;);</span><br><span class="line">&#125;   </span><br><span class="line">// ws的使用，以为按钮添加发送信息事件为例</span><br><span class="line">$(&quot;#send&quot;).click(function()&#123;</span><br><span class="line">    ws.send($(&quot;#msg&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="6-CORS-介绍"><a href="#6-CORS-介绍" class="headerlink" title="6.CORS 介绍"></a>6.CORS 介绍</h3><p>CORS是一个 W3C 标准，跨域资源共享（CORS ）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。简言之， CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。<br>下图为各浏览器对于 CORS 的支持情况，看起来相当乐观。主流浏览器都已基本提供对跨域资源共享的支持，所以，CORS 才会在国外使用的如此普遍。<br><img src="http://vfile.meituan.net/xgfe/d87439988ef5ab43251311a668d027d6233940.png" alt=""><br>使用 CORS 需要做服务端和前端的配置：</p><h4 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h4><p>以下是 CORS 协议规定的 HTTP 头，用来进行浏览器发起跨域资源请求时进行协商：</p><ol><li>Origin。HTTP 请求头，任何涉及 CORS 的请求都必需携带。</li><li>Access-Control-Request-Method。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的方法。</li><li>Access-Control-Request-Headers。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的自定义 Header 列表。</li><li>Access-Control-Allow-Origin。HTTP 响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符 * 表示允许任何域的JavaScript 访问资源，但是在响应一个携带身份信息( Credential )的 HTTP 请求时，Access-Control-Allow-Origin 必需指定具体的域，不能用通配符。</li><li>Access-Control-Allow-Methods。HTTP 响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li><li>Access-Control-Allow-Headers。HTTP 响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li><li>Access-Control-Max-Age。HTTP 响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li><li>Access-Control-Allow-Credentials。HTTP 响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回。</li></ol><p>实际应用中，服务端例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//允许跨域访问  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,PUT&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Test&quot;);</span><br></pre></td></tr></table></figure><h4 id="前端的配置"><a href="#前端的配置" class="headerlink" title="前端的配置"></a>前端的配置</h4><p>前端的配置主要从简单请求、非简单请求和携带身份凭证这三点进行讲解。<br>浏览器将CORS请求分成两类：简单请求（ simple request ）和非简单请求（ not-so-simple request ）。<br>1.简单请求：<br>使用下列方法：GET、 HEAD、 POST<br>HTTP的头信息主要是以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值属于下列之一: <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><p>简单请求如图所示：<br><img src="http://vfile.meituan.net/xgfe/63958e7743ea262c379f4466c52844a636486.png" alt=""><br>2.非简单请求：<br>不满足简单请求条件的请求则要先进行预检请求，即使用 OPTIONS 方法发起一个预检请求到服务器，已获知服务器是否允许该实际请求。<br>非简单请求如下所示：<br><img src="http://vfile.meituan.net/xgfe/cf3757d6cc10ac2d4c9c023af564900f126443.png" alt=""><br>浏览器与服务器之间请求只进行了一次。<br>下面是 PUT 请求第一次返回的结果：<br><img src="http://vfile.meituan.net/xgfe/33d389422e08f9f730faa7757ef26bba81218.png" alt=""><br><img src="http://vfile.meituan.net/xgfe/000d4cf1b6d92837affcddef925df2a176640.png" alt=""><br>通过PUT请求结果可以看出，当检测到 PUT 请求为非简单请求时，浏览器便会发送一个预检请求，目的是询问，自定义头部 X-Custom-Header 的 PUT 请求是否被允许，浏览器返回了所有可以请求的方法和自定义的头部（把所有可以的返回是为了避免多次预检请求），这时候预检请求成功了，便会发送真正的PUT请求。</p><p>关于预检请求，需要注意一下两点：</p><ul><li>预检请求对 js 来说是透明的，js 获取不到预检请求的任何信息。</li><li>预检请求并不是每次请求都发生，服务端设置的 Access-Control-Max-Age 头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发生预检请求。</li></ul><p>3.携带身份凭证<br>大部分的请求是需要用户携带着用户信息的，比如在一个登录的系统中，用户会携带着相应的 cookie 或 token ，但 CORS 跨域默认是不带身份凭证的。<br>如果需要附带身份凭证，在发送请求时，通过将 withCredentials 属性设置为 true ，可以指定某个请求可以发送凭据。<br>下面提供针对 XMLHttpRequest 附带身份凭证的兼容性写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function createCORSRequest(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr == 304) &#123;</span><br><span class="line">                console.log(xhr.response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(&apos;withCredentials&apos; in xhr) &#123;</span><br><span class="line">        xhr.open(method,url, true);</span><br><span class="line">    &#125; else if(typeof XDomainRequest != &apos;undefined&apos;) &#123;</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附带身份凭证对服务端有两个要求：</p><ol><li>服务端的 Access-Control-Allow-Origin 头部不能设置为 *</li><li>服务端的 Access-Control-Allow-Credentials 头部设置为 true</li></ol><h2 id="二、-前后端跨域通信"><a href="#二、-前后端跨域通信" class="headerlink" title="二、 前后端跨域通信"></a>二、 前后端跨域通信</h2><ul><li>JSONP</li><li>Hash</li><li>WebSocket</li><li>CORS</li></ul><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 的工作原理：<br>本质是利用了 script 标签具有可跨域的特性，由服务端返回预先定义好的 javascript 全局函数的调用，并且将服务端数据以该函数参数的形式传递过来。比如说，客户端这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>实际开发中，前端的 JSONP 是这样实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> var util = &#123;&#125;; </span><br><span class="line"> //定义方法：动态创建script标签</span><br><span class="line"> util.createScript = function (url, charset) &#123;</span><br><span class="line">     var script = document.createElement(&apos;script&apos;);</span><br><span class="line">     script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">     charset &amp;&amp; script.setAttribute(&apos;charset&apos;, charset);</span><br><span class="line">     script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">     script.async = true;</span><br><span class="line">     return script;</span><br><span class="line">&#125;;</span><br><span class="line"> util.jsonp = function (url, onsuccess, onerror, charset) &#123;  </span><br><span class="line">     //事先约定好的函数名</span><br><span class="line">     var callbackName = util.getName(&apos;tt_player&apos;);  </span><br><span class="line">     //根据回调名称注册一个全局的函数 </span><br><span class="line">     window[callbackName] = function () &#123;               </span><br><span class="line">         if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">             onsuccess(arguments[0]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //动态创建一个script标签</span><br><span class="line">     var script = util.createScript(url + &apos;&amp;callback=&apos; + callbackName, charset);   </span><br><span class="line">     //监听加载成功的事件，获取数据</span><br><span class="line">     script.onreadystatechange = function () &#123;      </span><br><span class="line">         if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123;              </span><br><span class="line">             if (script.parentNode) &#123;</span><br><span class="line">                 // 删除函数或变量</span><br><span class="line">                 script.parentNode.removeChild(script);  </span><br><span class="line">             &#125;      </span><br><span class="line">             //最后不要忘了删除           </span><br><span class="line">             window[callbackName] = null;  </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     script.onerror = function () &#123;                              </span><br><span class="line">         if (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">             onerror();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //往html中增加这个标签，目的是把请求发送出去</span><br><span class="line">     document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><p>url 的#后面的内容就叫 Hash 。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。<br>补充：url 的?后面的内容叫 Search 。 Search 的改变，会导致页面刷新，因此不能做跨域通信。<br>使用举例：<br>场景：我的页面 A 通过 iframe 或 frame 嵌入了跨域的页面 B。<br>现在，我这个 A 页面想给B页面发消息，怎么操作呢？<br>（1）首先，在我的A页面中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码  </span><br><span class="line">var B = document.getElementsByTagName(&apos;iframe&apos;);  </span><br><span class="line">//我们可以把JS对象，通过JSON.stringify()方法转成json字符串，发给B   </span><br><span class="line">B.src = B.src + &apos;#&apos; + &apos;jsonString&apos;;</span><br></pre></td></tr></table></figure><p>（2）然后，在 B 页面中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// B 中的伪代码     </span><br><span class="line">window.onhashchange = function () &#123; </span><br><span class="line">     //通过onhashchange方法监听，url中的hash是否发生变化         </span><br><span class="line">     var data = window.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>总结：<br>本文主要对前后端通信的几种方式做了简单介绍，希望对大家对前后端通信方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://blog.csdn.net/a54654132/article/details/77604597" target="_blank" rel="noopener">https://blog.csdn.net/a54654132/article/details/77604597</a><br><a href="https://www.cnblogs.com/yanglang/p/6720887.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/6720887.html</a><br><a href="https://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/8523576.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/6337580.html</a><br><a href="https://blog.csdn.net/qq_27905183/article/details/71023542" target="_blank" rel="noopener">https://blog.csdn.net/qq_27905183/article/details/71023542</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ANJING" scheme="http://xgfe.github.io/categories/ANJING/"/>
    
    
      <category term="前后端通信" scheme="http://xgfe.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的十种方法</title>
    <link href="http://xgfe.github.io/2018/06/07/yuxue/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://xgfe.github.io/2018/06/07/yuxue/数组去重的十种方法/</id>
    <published>2018-06-07T03:12:00.000Z</published>
    <updated>2019-05-05T02:41:48.403Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。</p><a id="more"></a><h2 id="一、-双重遍历"><a href="#一、-双重遍历" class="headerlink" title="一、 双重遍历"></a>一、 双重遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.splice(j,<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.unique();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr1.unique1();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>双重遍历的方式是最容易想到且最容易实现的方式，兼容性比较好，但是时间复杂度比较高；还有一点是不能对 NaN 进行去重。</p><h2 id="二、-indexOf"><a href="#二、-indexOf" class="headerlink" title="二、 indexOf"></a>二、 indexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(newArr.indexOf(<span class="keyword">this</span>[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2.unique2();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="三、-数组下标判断"><a href="#三、-数组下标判断" class="headerlink" title="三、 数组下标判断"></a>三、 数组下标判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) === i) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line">arr3.unique3();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>因为 indexOf 使用的内部严格相等比较算法，所以在检索NaN时会返回-1 ，进而会导致方法3直接过滤掉了 NaN。</p><h2 id="四、排序再去重"><a href="#四、排序再去重" class="headerlink" title="四、排序再去重"></a>四、排序再去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];<span class="keyword">this</span>.sort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] !== newArr[newArr.length<span class="number">-1</span>]) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr4.unique4();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>优点是利用 js 内置的排序方法，速度快，比较的是排序后的相邻元素。最大的不同是更改了原数组的排序。</p><h2 id="五、利用对象的属性"><a href="#五、利用对象的属性" class="headerlink" title="五、利用对象的属性"></a>五、利用对象的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!obj[<span class="keyword">this</span>[i]])&#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">obj[<span class="keyword">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr5.unique5();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">let</span> arr6 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique6 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> tmpKey;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">tmpKey = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i]);</span><br><span class="line"><span class="keyword">if</span>(!obj[tmpKey]) &#123;</span><br><span class="line">obj[tmpKey] = <span class="number">1</span>;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr6.unique6();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>由于对象的键名只能是 String，所以版本1的局限性在于</p><ol><li><p>无法区分隐式类型转换成字符串后一样的值，比如 1 和 “1”</p></li><li><p>无法处理复杂类型，比如对象（因为对象作为key会变成[ object Object ]）</p></li><li><p>特殊数据，比如 <code>__proto__</code> 会挂掉，因为obj对象的 <code>__proto__</code> 属性无法被重写</p></li></ol><p>版本2的优化则解决了这三个问题。缺点就是实现的方式比较麻烦。</p><h2 id="六、-reduce"><a href="#六、-reduce" class="headerlink" title="六、 reduce"></a>六、 reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique7 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">initialValue, current</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(initialValue.length === <span class="number">0</span> || initialValue[initialValue.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">initialValue.push(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> initialValue;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr7.unique7();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>原理实际同方法四，都是进行排序后比较相邻的两个值。</p><h2 id="七、-filter"><a href="#七、-filter" class="headerlink" title="七、 filter"></a>七、 filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr8 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique8 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.indexOf(ele) === index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr8.unique8();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><h2 id="八、-es6-includes"><a href="#八、-es6-includes" class="headerlink" title="八、 es6 includes"></a>八、 es6 includes</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr9 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>,  <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique9 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!newArr.includes(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr9.unique9();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>与 indexOf 类似，但不同的是 indexOf 使用的严格比较，includes 使用的是叫做 SameValueZero 的比较，规范中给出 If x is NaN and y is NaN, return true. 也就是 includes 可以对NaN去重。</p><h2 id="九、-es6-Map"><a href="#九、-es6-Map" class="headerlink" title="九、 es6 Map"></a>九、 es6 Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr10 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique10 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tmp.get(<span class="keyword">this</span>[i]))&#123;</span><br><span class="line">tmp.set(<span class="keyword">this</span>[i], <span class="number">1</span>);</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr10.unique10();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="十、-es6-Set"><a href="#十、-es6-Set" class="headerlink" title="十、 es6 Set"></a>十、 es6 Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr11 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr11)]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>利用 set 对象存储任何类型的唯一值的特性来达到去重的目的。</p><p>再来来看看这几种方式直观的性能对比。<br>通过以下的模拟数据的形式来执行我们上面介绍的每一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复100次生成1~10000的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArr</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> create = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line">            create.push(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算去重函数的时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    fn();</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">var</span> result = date2 - date1;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lgArr = createArr();</span><br><span class="line"><span class="keyword">const</span> res = checkTime(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> lgArr.unique()&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&#123;method：loop，time:"</span> + res + <span class="string">"&#125;"</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://vfile.meituan.net/xgfe/84a60f898fc7283c3ce2dc70d770b137116872.png" alt=""></p><p>在考虑兼容性,并且可以接受以上所说的 Object.key 的限制时，用对象属性方式是最快的。如果考虑这些限制，就要用到对象属性的优化方案，增加对 key 的类型的判断，但这样做显然会麻烦很多，如果处理不好还可能导致结果出错。那么在数据量比较小的情况下，选用 indexof 不失为一种更加稳妥的办法。</p><p>在现代浏览器中当然首选的是 es6 的 set 和 map ,方便易用。在不关注排序的情况下，reduce 和 sort 也是比较可取的方式。<br>以上仅仅是从时间维度上的个人分析。实际工作中还要根据情况进行综合考虑来选择最合适的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。&lt;/p&gt;
    
    </summary>
    
      <category term="yuxue" scheme="http://xgfe.github.io/categories/yuxue/"/>
    
    
      <category term="数组" scheme="http://xgfe.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="去重" scheme="http://xgfe.github.io/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>移动前端开发中的伪装术</title>
    <link href="http://xgfe.github.io/2018/05/30/zhaojun/hybrid/"/>
    <id>http://xgfe.github.io/2018/05/30/zhaojun/hybrid/</id>
    <published>2018-05-30T04:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.407Z</updated>
    
    <content type="html"><![CDATA[<p>本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年双十一，中国客单占比中，有近90%的用户，使用移动设备下单。移动互联网在中国的普及程度可见一斑。正是因为用户终端的转变，前端攻城狮们的技能树也需要改变。</p><h2 id="战场的转移"><a href="#战场的转移" class="headerlink" title="战场的转移"></a>战场的转移</h2><p>目前前端攻城狮（由于背景是针对原本的web前端，本文暂时不把iOS和Android开发归入前端攻城狮的队伍中，虽然现在广义上来说app开发也属于前端开发）在移动端的主要战场有以下几个：</p><ol><li>普通浏览器网页的移动端响应式适配</li><li>hybrid（含微信小程序）</li><li>react native</li><li>PWA（暂时还是非主流）</li></ol><p>用一个表格整理一下</p><table><thead><tr><th></th><th>流畅度</th><th>交互体验</th><th>开发学习成本</th><th>功能及限制</th><th>发布</th></tr></thead><tbody><tr><td>移动端网页</td><td>最低</td><td>差</td><td>低，兼容性和响应式</td><td>需要浏览器运行，功能被浏览器限制</td><td>与web前端一致</td></tr><tr><td>Hybrid（含小程序）</td><td>低</td><td>较好</td><td>一套代码两端复用</td><td>通过JSBridge，SDK调用原生功能</td><td>通过热更新</td></tr><tr><td>React Native</td><td>高</td><td>好</td><td>一套代码两端复用，有个别组件和属性有平台差异</td><td>本身有组件和API可以调用部分原生功能，也可以用Bridge</td><td>通过热更新</td></tr><tr><td>原生APP</td><td>最高</td><td>最佳</td><td>学习成本大，需要开发ios端和安卓端</td><td>无限制</td><td>有审核，版本兼容问题多</td></tr></tbody></table><p>前端攻城狮在移动互联网的时代中是既希望保留前端开发敏捷灵活的特点，也希望可以给用户更好的交互体验。</p><h2 id="原生APP的交互体验"><a href="#原生APP的交互体验" class="headerlink" title="原生APP的交互体验"></a>原生APP的交互体验</h2><p>一个好的APP到底会和一个移动端网页有什么样的区别，这些差异能不能通过一些技术上的优化来抹平？</p><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>原生APP与WEB网页最直观的的区别就是UI上，APP和网页在设计上有很多各自的风格，当然这种风格上的差距是可以轻易抹平的。<br>UI的设计资源在前端团队中是非常的重要。比如说Ant Design提供的一些思路和实践：字体，行高，空白的大小都可以固定为一些常量，交互和组件UI包含在了组件之中。<br>简单说一下取色的过程。<a href="http://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">参考链接</a><br><img src="https://ws1.sinaimg.cn/large/6f3ac581gy1fv7x26gopdj20ow0gkmy0.jpg" alt=""><br>一般来说在设计过程中，一个应用多数是会有主色，辅助色，强调色。而在实际的开发中，例如图中蓝色的主色又会衍生为hover、click、disable等几种状态，如果一个项目并没有UI的介入，此时自动通过一个主色调，衍生出多种色彩就显得很重要。除了通过类似<a href="https://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">Ant Design的取色板</a>帮助取色外，也可以通过代码的手段。衍生颜色的过程其实就是HSV颜色空间的变化。这里不详述这一点了。</p><h3 id="交互感"><a href="#交互感" class="headerlink" title="交互感"></a>交互感</h3><p>以下是一些良好交互的例子：</p><ul><li>每个按钮在用户点击后都有反馈，例如颜色的变化或者是出现波纹</li><li>每个页面进出时或者是tab切换时都有动画</li><li>列表下拉上拉时出现弹性的动作</li></ul><p>这些良好的交互都是需要前端去实现的。<br>目前用户已经养成了一些移动端APP的使用习惯，比如用户会认为一个列表下拉的时候数据会重新刷新，上拉到底的时候数据会加载更多，一个按钮点击的时候会产生背景颜色的变化等等。所以需要将交互的模式和动画利用UI、UE积累的设计资源沉淀到组件中。假设这些交互动画都可以流畅的实现，并且形成一套移动端的组件库，那么使用这套组件库开发的一个应用就可以有比较优秀的用户体验。比如说RN官方提供的<a href="https://reactnative.cn/docs/0.51/touchablenativefeedback.html#content" target="_blank" rel="noopener">TouchableNativeFeedback组件</a>，就实现了可以实现涟漪状的波纹。<br>另一个问题就是交互动画的流畅度能不能和原生应用媲美呢。由于手机的性能瓶颈，目前在移动端的动画仍然需要去进行优化保证动画的流畅度，就动画方面是有一些手段可以提升流畅度的：</p><ol><li>动画尽可能使用transform，而非直接操作dom</li><li>必要情况下使用will-change或者transform3D()去让Webview调用GPU做渲染</li><li>如果有dom操作考虑回流和重绘的优化。<a href="http://xgfe.github.io/2018/04/15/zhangjianfeng/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">可参考</a></li><li>防抖和节流，优化一些频繁操作</li></ol><p>RN实现动画的话，则可以通过Animated库实现流畅又好看的动效。<a href="https://reactnative.cn/docs/0.51/animations.html" target="_blank" rel="noopener">RN动画参考</a></p><h3 id="手势操作"><a href="#手势操作" class="headerlink" title="手势操作"></a>手势操作</h3><p>多点触控可以组成一系列的手势操作，这个是智能手机的体验优势，原生的APP可以很好的支持手势事件，做出流畅的交互体验。JS也可以通过touch库去监听到手势，并作出交互；另外在RN上对手势则有天然的支持。<a href="https://reactnative.cn/docs/0.51/gesture-responder-system.html#content" target="_blank" rel="noopener">参考链接</a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>下图是一个react的Hybrid项目在webview中渲染出来的过程<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frt5z11h1kj20ta088q37.jpg" alt=""></p><p>基于这个过程有以下一些加速方案，主要分为两类，网络类和渲染类。<br>首先是网络类</p><ul><li>在兼顾APP包大小的前提下，将一部分资源放入离线包。</li><li>采用HTTP缓存，减少资源的重复请求。</li><li>拆分快慢接口，首屏展示时尽可能不要先请求慢接口。</li><li>升级到HTTP2，多路复用。</li><li>DNS寻址优化。</li><li>本地数据缓存，先使用本地数据渲染页面，然后等线上数据更新下来后再更新视图。</li><li>缓存的差分更新。</li><li>减少cookie的传输。</li></ul><p>附上一个<a href="https://zhuanlan.zhihu.com/p/24202408" target="_blank" rel="noopener">美团大众点评Hybrid</a>资源预加载的方案<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1fv7wzeaxgfj20k00d6aar.jpg" alt=""></p><p>渲染类</p><ul><li>在页面拿到基础的dom结构后，优先用占位符的方式，尽快缩减页面渲染的体感时长。</li><li>MVVM框架中减少不必要的的DOM更新。</li><li>首屏渲染的直出。</li><li>尽可能减少Webview中的JS代码，让Webview专一的处理渲染工作，业务和框架JS放入JSCore中，Webview和JSCore通过桥通信更新DOM<br>节点。</li></ul><h4 id="Webview与jsCore"><a href="#Webview与jsCore" class="headerlink" title="Webview与jsCore"></a>Webview与jsCore</h4><p>微信小程序就是二者分离的典型实践。微信小程序直接进行平时前端的DOM操作是不支持的，原因就是脚本的运行环境是JSCore并不支持DOM和BOM对象。微信小程序对MVVM模式在Hybrid上给出的最佳实践就是：业务脚本，虚拟DOM的diff交给JSCore，让Webview可以专心致志的去完成DOM的渲染，事件监听，DOM的更新工作。<br>Hybrid一个桥连接Webview和native的实践很常见，如果像微信一样用到Webview和JSCore的话需要两个桥。<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frtbophcnfj20g503xmx5.jpg" alt=""><br>JSBridge实际上可以算作是一个<a href="https://segmentfault.com/a/1190000014206309" target="_blank" rel="noopener">EventEmitter</a>的变形。<br>JS部分的核心接口的伪代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册函数，用于被native调用</span></span><br><span class="line"><span class="keyword">const</span> addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(fn)) <span class="keyword">return</span>;<span class="comment">//判断是否在监听中添加的是合法的函数</span></span><br><span class="line">    <span class="comment">//判断type是否添加过，添加过一个还是多个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.event[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(<span class="keyword">this</span>.event[type]))&#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd将push改为unshift即可</span></span><br><span class="line">            <span class="keyword">this</span>.event[type].push(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd改变顺序</span></span><br><span class="line">            <span class="keyword">this</span>.event[type] = [<span class="keyword">this</span>.event[type], fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.event[type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是向native发送消息的postMessage函数，核心的信息是option</p><ul><li>name: 对应了在addListener中的type</li><li>data: 给native中传递的数据</li><li>callback: 回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//postMessage是用于调用native</span></span><br><span class="line"><span class="keyword">const</span> nativeBridge = getBridge();<span class="comment">//根据平台获取bridge</span></span><br><span class="line"><span class="keyword">const</span> postMessage = <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = createID(option.name);<span class="comment">//生成唯一id</span></span><br><span class="line">    addListener(id, option.callBack);</span><br><span class="line">    nativeBridge.post(&#123;</span><br><span class="line">        name: option.name,</span><br><span class="line">        data: option.data,</span><br><span class="line">        cbId: id</span><br><span class="line">    &#125;);<span class="comment">//通知native</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> receiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">this</span>.event[option.cbId];</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(handle.call(<span class="literal">null</span>, option.message)).then(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        postMessage(&#123;</span><br><span class="line">            name: option.name,</span><br><span class="line">            data: args</span><br><span class="line">        &#125;);<span class="comment">//执行native的回调</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用两个桥在JSCore中可以在执行业务逻辑代码，及虚拟dom diff后将需要进行dom修改结果通过告知native<br>option可以如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'domUpdate'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        pageId: <span class="string">'xxx'</span>,</span><br><span class="line">        componentId: <span class="string">'xxx'</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            type: <span class="string">'text'</span>,</span><br><span class="line">            content: <span class="string">'换了换了'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            type: <span class="string">'span'</span>,</span><br><span class="line">            children: [&#123;</span><br><span class="line">                type: <span class="string">'text'</span>,</span><br><span class="line">                content: <span class="string">'我也换了'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;],</span><br><span class="line">        type:</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'updateDown'</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native发现是domUpdate后通知webview的DomUpdate，根据page，component及data进行DOM的更新</p><p>以上就是利用JSCore进行渲染加速的一点思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做Hybrid项目和RN项目中，更多的关注性能和体验，渲染层面的优化很多需要整体方案的革新或者整个框架的支持，不过在组件层面交互的优化是性价比最高，也相对容易实现的手段。这就需要在移动端的业务开发工作中积累组件，雕琢交互体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。&lt;/p&gt;
    
    </summary>
    
      <category term="zhaojun" scheme="http://xgfe.github.io/categories/zhaojun/"/>
    
    
      <category term="React Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="前端优化实践" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="移动端" scheme="http://xgfe.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="hybrid" scheme="http://xgfe.github.io/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>Egg.js 体验</title>
    <link href="http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/"/>
    <id>http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/</id>
    <published>2018-05-26T07:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.379Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。<br><a id="more"></a></p><h2 id="Egg-js-是什么"><a href="#Egg-js-是什么" class="headerlink" title="Egg.js 是什么?"></a>Egg.js 是什么?</h2><p>﻿Egg.js 是一个强约束的 Node 框架，这也是和 Express / Koa 最大的不同，后者对开发者相对宽松，主要体现在目录结构、编写方式等均可以自定义，标准的 mvc 模式有千奇百怪的写法。</p><p> Egg.js 奉行『约定优于配置』，他规定一定的约定，让开发者都按照统一的约定去开发，降低团队协作成本，减少差异，求同存异，提升项目阅读和维护性。但约定不等于扩展性差，相反 Egg.js 有很高的扩展性。</p><h3 id="特性"><a href="#特性" class="headerlink" title="﻿特性"></a>﻿特性</h3><pre><code>* 提供基于 Egg 定制上层框架的能力* 高度可扩展的插件机制* 内置多进程管理* 基于 Koa 开发，性能优异* 框架稳定，测试覆盖率高* 渐进式开发</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>官方推荐使用脚手架快速生成项目：</p><pre><code>$ npm install egg-init -g$ egg-init egg-test --type=simple$ cd egg-test$ npm install$ npm run dev$ open localhost:7001</code></pre><p>Egg.js 给我们规定的目录结构如下图：</p><pre><code>﻿egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app|   ├── router.js│   ├── controller│   |   └── home.js│   ├── service (可选)│   |   └── user.js│   ├── middleware (可选)│   |   └── response_time.js│   ├── schedule (可选)│   |   └── my_task.js│   ├── public (可选)│   |   └── reset.css│   ├── view (可选)│   |   └── home.tpl│   └── extend (可选)│       ├── helper.js (可选)│       ├── request.js (可选)│       ├── response.js (可选)│       ├── context.js (可选)│       ├── application.js (可选)│       └── agent.js (可选)├── config|   ├── plugin.js|   ├── config.default.js│   ├── config.prod.js|   ├── config.test.js (可选)|   ├── config.local.js (可选)|   └── config.unittest.js (可选)└── test    ├── middleware    |   └── response_time.test.js    └── controller        └── home.test.js</code></pre><p>﻿其中包括 controller、router 、config 等等，然后我们需要先添加一个渲染模版；Eggjs 提供了很多 view 模版，这里选择 Egg-view-ejs 为例，安装完插件后需要在 config 里面开启插件，同时需要在 app 文件夹下新建 view 文件夹，放置页面文件。<br> 配置需要用的插件，在 config / plugin.js 中添加</p><pre><code>﻿exports.ejs = {    enable: true,    package: &apos;egg-view-ejs&apos;};// 使用 mysql 插件exports.mysql = {    enable: true,    package: &apos;egg-mysql&apos;,};</code></pre><p>开启插件，config.default.js 中增加</p><pre><code>﻿config.view = {    defaultViewEngine: &apos;ejs&apos;,    mapping: {        &apos;.html&apos;: &apos;ejs&apos;,    }，};// 设置 mysqlconfig.mysql = {    clients: {        // clientId, 获取 client 实例，需要通过 app.mysql.get(&apos;clientId&apos;) 获取        db: {            ...        }    },    // 是否加载到 app 上，默认开启    app: true,};</code></pre><p>﻿其中 defaultViewEngine 表示使用的模版，当然也可以使多种模版。mapping 设置的属性名表示 view 中文件的扩展名，属性值表示对应的模板；接下来就可以编写 controller 和 router 了。<br> 定义 controller，﻿在 controller 文件夹下的 home.js 中：</p><pre><code>﻿const Controller = require(&apos;egg&apos;).Controller;// eggjs 推荐使用类形式来定义class HomeController extends Controller {  async index() {      await this.ctx.render(&apos;site/home.html&apos;);  }}module.exports = HomeController;</code></pre><p>定义路 router，在 router.js 文件中：</p><pre><code>﻿module.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/&apos;, controller.home.index);    router.get(&apos;/login&apos;, controller.login.index);};</code></pre><p>﻿Context 对象上提供了 3 个渲染模版的接口，返回值均为 Promise:</p><pre><code>﻿// render ：渲染模版文件，data 为传入模版的数据，并赋值给 ctx.bodyawait ctx.render(&apos;home/index.tpl&apos;, data);// renderView ：渲染模版文件，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderView(&apos;path/to/file.tpl&apos;, data);// renderString ：渲染模版字符串，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderString(&apos;hi, {{ name }}&apos;, data, {    // 需要指定模板引擎    viewEngine: &apos;nunjucks&apos;,});</code></pre><h2 id="内置基础对象扩展"><a href="#内置基础对象扩展" class="headerlink" title="内置基础对象扩展"></a>内置基础对象扩展</h2><p>框架包括从 Koa 继承而来的 4 个对象（ Application、Context、Request、Response )以及框架扩展的一些对象（ Controller、Service、Helper、Config、Logger ）。</p><h3 id="Application-扩展"><a href="#Application-扩展" class="headerlink" title="Application 扩展"></a>Application 扩展</h3><p>app 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建。在 Controller、Middleware、Helper、Service 中都可以通过<br>this.app 访问到 Application 对象。框架会把 app/extend/application.js 中定义的对象与 Koa Application 的 prototype 对象进行合并，在应用启动时会基于扩展后的 prototype 生成 app 对象。这样能在其他地方使用 Application 中扩展的方法。</p><pre><code>﻿// app/extend/application.jsmodule.exports = {  foo(params) {    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性  },};</code></pre><h3 id="Context-扩展"><a href="#Context-扩展" class="headerlink" title="﻿Context 扩展"></a>﻿Context 扩展</h3><p>Context 指的是 Koa 的请求上下文，这是请求级别的对象，每次请求生成一个 Context 实例，通常我们也简写成 ctx。在所有的文档中，Context 和 ctx 都是指 Koa 的上下文对象。如下做的是对数据返回的扩展：</p><pre><code>﻿// app/extend/context.jsmodule.exports = {  returnJson(code,data,msg) {    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性    this.body={code,data,msg};    return  }};在 controller 中就可以直接使用这个方法了async info() {    const userId = this.ctx.query.id;    const res = await this.ctx.service.getInfo(userId);    this.ctx.returnJson(0, res, &quot;请求成功&quot;);}</code></pre><h3 id="Request-和-Response-扩展"><a href="#Request-和-Response-扩展" class="headerlink" title="﻿Request 和 Response 扩展"></a>﻿Request 和 Response 扩展</h3><p> ﻿ctx 上的很多属性和方法都被代理到 request 和 response 对象上，对于这些属性和方法使用 ctx 和使用 request 去访问它们是等价的，例如 ctx.url === ctx.request.url、ctx.status === ctx.response.status 。<br> 框架会把 app/extend/request.js 中定义的对象与内置 request 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 request 对象；Response 的扩展和 Request 相同。</p><pre><code>﻿// app/extend/request.jsmodule.exports = {  get foo() {    return this.get(&apos;request-foo&apos;);  },};// app/extend/response.jsmodule.exports = {  set bar(value) {    this.set(&apos;response-bar&apos;, value);  },};</code></pre><h3 id="Helper-扩展"><a href="#Helper-扩展" class="headerlink" title="﻿Helper 扩展"></a>﻿Helper 扩展</h3><p>﻿Helper 函数用来提供一些常用的方法或自定义的方法，可以将项目中用的多的函数封装在成对的函数，并且 Helper 对象可以在 ctx 对象里面访问到。</p><pre><code>﻿// app/extend/helper.jsmodule.exports = {  foo(param) {    // this 是 helper 对象，在其中可以调用其他 helper 方法    // this.ctx =&gt; context 对象    // this.app =&gt; application 对象  },};</code></pre><h2 id="service-服务层"><a href="#service-服务层" class="headerlink" title="﻿service 服务层"></a>﻿service 服务层</h2><p>﻿service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。可以将数据逻辑的处理都放在 service 中</p><pre><code>﻿const Service = require(&apos;egg&apos;).Service;class UserService extends Service {  async find(uid) {    const user = await app.mysql.get(&apos;db&apos;).query(`select * from user where uid = ${uid}`);    return user;  }}module.exports = UserService;</code></pre><h2 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="﻿Middleware 中间件"></a>﻿Middleware 中间件</h2><p>﻿Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。约定中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：</p><pre><code>options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。app: 当前应用 Application 的实例。</code></pre><p>﻿定义一个中间件：</p><pre><code>﻿module.exports = (options,app) =&gt; {    return async function checkLogin() {        if(!(this.session &amp;&amp; this.session.userid)){            this.redirect(&apos;/login&apos;);            return;        };        // 刷新 session 时间        this.session.save();    };}</code></pre><p>﻿在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。配置最终将在启动时合并到 app.config.appMiddleware 中。在 config.default.js 中配置如下：</p><pre><code>﻿// 配置需要的中间件，数组顺序即为中间件的加载顺序config.middleware= [&apos;checkLogin&apos;];// 配置 checkLogin 中间件的配置config.checkLogin= {    // 设置需要忽略检查的路径    ignore: &apos;/login&apos;};</code></pre><p> ﻿利用上述定义的中间件，如下是做的一个简单的登录</p><pre><code>﻿// router.jsmodule.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/login&apos;, controller.login.index);    router.post(&apos;/login/vaild&apos;, controller.login.valid);    // 登陆后获取用户名    router.get(&apos;/user/admin&apos;, controller.login.userinfo);    // 退出登录    router.get(&apos;/logout&apos;, controller.login.logout);}// app/controller/login.jsmodule.exports = app =&gt; {    class LoginController extends app.Controller {        async index() {                await this.ctx.render(&apos;site/login.html&apos;);        }        async valid() {            const name = this.ctx.request.body.username;            const pwd = this.ctx.request.body.password;            if (!name || !pwd) {                // 1表示没有填写                this.ctx.returnJson(1,&apos;&apos;,&quot;请填写帐号和密码。&quot;)                return;            }            const user = await app.mysql.get(&apos;db&apos;).query(`select id,username  from user WHERE username= &apos;${name}&apos; AND password =&apos;${pwd}&apos;`);            if (user.length != 0) {                // 登录成功，下发 session                this.ctx.session.username = user[0].username;                this.ctx.session.userid = user[0].id;                // 设置过期时间为3小时                this.ctx.session.maxAge = 3 * 3600 * 1000;                // 调用 rotateCsrfSecret 刷新用户的 CSRF token                this.ctx.rotateCsrfSecret();                this.ctx.returnJson(0, &apos;&apos;, &quot;登录成功&quot;);            } else {                this.ctx.returnJson(2,&apos;&apos;,&quot;帐号或密码错误&quot;);            };        }        async userinfo() {            const uid = this.ctx.query.uid;            let user = await this.ctx.service.UserService.find(uid)            this.ctx.returnJson(0,user ,&quot;操作成功&quot;);        }        async logout() {            this.ctx.session = null;            this.ctx.redirect(&apos;/login&apos;);        }    }    return LoginController;};</code></pre><p>在这里面遇到一个坑就是通过 get 请求和 post 请求时，获取参数的方式不一样。</p><pre><code>* 在 get 请求中要通过 this.ctx.query 去获取参数；在 post 请求中是通过 this.ctx.request.body 去获取参数。</code></pre><p>﻿这些只是 Eggjs 的一小部分内容，框架还有很多扩展，插件，进程管理等等，接下来会通过自己的学习慢慢总结，有不对的地方还希望各位前辈指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="Eggjs" scheme="http://xgfe.github.io/tags/Eggjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 WEB 缓存</title>
    <link href="http://xgfe.github.io/2018/05/07/zhangjihu/%E6%B5%85%E8%B0%88web%E7%BC%93%E5%AD%98/"/>
    <id>http://xgfe.github.io/2018/05/07/zhangjihu/浅谈web缓存/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2019-05-05T02:41:48.405Z</updated>
    
    <content type="html"><![CDATA[<p>在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js ，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存根据进来的请求保存输出内容的副本，当再次请求的时候，如果是相同的URL，会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器发送请求。<br>Web 缓存机制的有多种，在这里主要探讨以浏览器为载体的 HTTP 缓存机制，希望对自己和大家都有所帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器缓存（ Brower Caching ）是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，浏览器缓存的优点：</p><ul><li>减少了冗余的数据传输，节省了网费</li><li>减少了服务器的负担，大大提升了网站的性能</li><li>加快了客户端加载网页的速度</li></ul><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起 HTTP 请求–服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/fbbc80627083b6bbe7ecb9525a36189434504.webp" alt=""></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取。</p><h2 id="浏览器缓存类型"><a href="#浏览器缓存类型" class="headerlink" title="浏览器缓存类型"></a>浏览器缓存类型</h2><p>我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control ，<strong>其中 Cache-Control 优先级比 Expires 高</strong>。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP / 1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header ，如：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/417893a96e4205a4c13acbc58941d25850878.png"></p><p>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header ）；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。<br>4、如果缓存没有命中，浏览器直接向服务器发送请求，Expires Header 在重新加载的时候会被更新。<br>到了 HTTP / 1.1 ，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 Cache-Control 又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在 HTTP / 1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：可以被所有的用户缓存，包括客户端和 CDN 等中间代理服务器，默认值</li><li>private：只能被客户端缓存，不允许 CDN 等中间代理服务器对其缓存，Cache-Control 的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存，每次请求该资源直接向服务器发送请求，每次都会下载完整的资源</li><li>max-age=xxx：（单位为 s ）：缓存内容将在 xxx 秒后失效，当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了</li><li>s-maxage=xxx：（单位为 s ）：同 max-age ，只用于共享缓存（比如 CDN 缓存），覆盖掉 max-age 和 Expires</li></ul><p>接下来，我们直接看一个例子，如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header ；<br>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/2f10fb6c2edd15f829d36330bee33b6b57447.png" alt=""></p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p><p>由上面的例子我们可以知道：</p><ul><li>HTTP 响应报文中 expires 的时间值，是一个绝对时间的GMT格式的时间字符串</li><li>HTTP 响应报文中 Cache-Control 为 max-age = 7200 ，是相对值，代表着资源的有效期</li></ul><p>由于 Cache-Control 的优先级比 expires ，那么直接根据 Cache-Control 的值进行缓存，意思就是说在 7200 秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。<br>注：在无法确定客户端的时间是否与服务端的时间同步的情况下， Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会携带缓存标识向服务器发起请求，验证协商缓存是否命中，由服务器根据缓存标识决定是否使用缓存，如果协商缓存命中，请求响应返回的 http 状态为 304 。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/165599b6e70d5fcc1258be192f6db41b36954.png" alt=""></p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/0416603a7ed8b6c6d8af6f548a6c570c26337.png" alt=""></p><p>查看单个请求的 ResponseHeader，也能看到 304 的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源。</p><h4 id="主要有以下两种情况："><a href="#主要有以下两种情况：" class="headerlink" title="主要有以下两种情况："></a>主要有以下两种情况：</h4><p>协商缓存生效，返回 304 ，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/cac3ffaa672010fee74692465e9c17f021484.webp" alt=""></p><blockquote><p>304</p></blockquote><p>协商缓存失效，返回 200 和请求结果结果，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/76908dc6fb49340ad92d97ff2ed759ba22094.riff" alt=""></p><blockquote><p>200</p></blockquote><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match ，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。</p><h5 id="【-Last-Modified，If-Modified-Since-】"><a href="#【-Last-Modified，If-Modified-Since-】" class="headerlink" title="【 Last-Modified，If-Modified-Since 】:"></a>【 Last-Modified，If-Modified-Since 】:</h5><p>Last-Modified 是该资源文件最后一次更改时间，服务器会在 response header 里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到 request header 里的 If-Modified-Since 里，服务器在接收到后也会做比对，如果相同则命中协商缓存，具体情况如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</p><p><img src="http://vfile.meituan.net/xgfe/d5788526358fd1f02278de827d0cc8f481865.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b150d289f5ec7c2921d175d4aad1dd8a81884.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容，状态码为 200。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header 。<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。<br>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p><h5 id="【-ETag-、If-None-Match-】"><a href="#【-ETag-、If-None-Match-】" class="headerlink" title="【 ETag 、If-None-Match 】:"></a>【 ETag 、If-None-Match 】:</h5><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header ，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</p><p><img src="http://vfile.meituan.net/xgfe/f8e13201a0acfa1c34a07f978ab8eb1560458.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header ，这个 header 的值就是上一次请求时返回的 ETag 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b3ee027ffc12d12ee34cfdeaebff931f103431.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag ，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified ，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。</p><h5 id="为什么要有-Etag"><a href="#为什么要有-Etag" class="headerlink" title="为什么要有 Etag"></a>为什么要有 Etag</h5><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？ HTTP 1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：<br>    • 一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET ；<br>    • 某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比方说 1 s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）；<br>    • 某些服务器不能精确的得到文件的最后修改时间。<br>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag ，一致的情况下，才会继续比对 Last-Modified ，最后才决定是否返回 304 。</p><h3 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h3><p>强缓存与协商缓存的区别可以用下表来表示：</p><p><img src="http://vfile.meituan.net/xgfe/f0eb26fac54900ef2272f4c3e3e233ef20064.png" alt=""></p><p>强制缓存优先于协商缓存进行，若强制缓存（ Expires 和 Cache-Control ）生效则直接使用缓存，若不生效则进行协商缓存（ Last-Modified / If-Modified-Since 和 Etag / If-None-Match ），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304 ，继续使用缓存。</p><h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>1、浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并缓存；<br>2、下一次加载资源时，先比较当前时间和上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age ，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP 1.1 ，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求；<br>3、服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304 ；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200 ；<br>4、如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304 ；不一致则返回新的 last-modified 和文件并返回 200 ；</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/735836ddebf6bf03fb577902c88afd6925020.webp" alt=""></p><h3 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" class="headerlink" title="用户行为对缓存的影响"></a>用户行为对缓存的影响</h3><p>地址栏访问，点击链接跳转是正常用户行为，将会触发浏览器缓存机制，浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容；<br>F5 刷新，浏览器会设置 max-age = 0，跳过强缓存判断，会进行协商缓存判断；<br>ctrl + F5 刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</p><p><img src="http://vfile.meituan.net/xgfe/72ef16289230d836b2027eb7f6a6845c27545.png" alt=""></p><h3 id="已经缓存的响应，如何更新或废弃？"><a href="#已经缓存的响应，如何更新或废弃？" class="headerlink" title="已经缓存的响应，如何更新或废弃？"></a>已经缓存的响应，如何更新或废弃？</h3><p>一般情况下，浏览器发出的所有 HTTP 请求会首先被路由到浏览器的缓存，以查看是否缓存了可以用于实现请求的有效响应。如果有匹配的响应，会直接从缓存中读取响应，这样就避免了网络延迟以及传输产生的数据成本。然而，如果我们希望更新或废弃已缓存的响应，该怎么办？<br>假设我们已经告诉访问者某个 CSS 样式表缓存长达 24 小时（ max-age = 86400 ），但是设计人员刚刚提交了一个更新，我们希望所有用户都能使用。我们该如何通知所有访问者缓存的 CSS 副本已过时，需要更新缓存？<br>实际上以前没有请求过该资源的新的用户会得到更新的资源，但是请求过资源的用户将在过期时间达到之前一直得到旧的被缓存的资源，直到他手动的去清理了浏览器的缓存。手动清理浏览器缓存这种事可能只有程序员才会做，那么我们要怎么做才能让用户得到更新后的资源呢？<br>其实很简单，我们可以在资源的内容更改后，更改资源的网址，强制用户下载新响应。比如在资源链接后添加参数：</p><p><img src="http://vfile.meituan.net/xgfe/29b12a26033d0eccff1a6d503ae8f9f674695.png" alt=""></p><p>（有兴趣的可以阅读：<a href="https://www.zhihu.com/question/20790576）" target="_blank" rel="noopener">https://www.zhihu.com/question/20790576）</a></p><h2 id="web-缓存作用"><a href="#web-缓存作用" class="headerlink" title="web 缓存作用"></a>web 缓存作用</h2><p>1、减少网络带宽消耗<br>无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当 Web 缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。</p><p>2、降低服务器压力<br>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><p>3、减少网络延迟，加快页面打开速度<br>缓存的使用能够明显加快页面打开速度，提高网页性能，达到更好的体验。</p><h2 id="其它-web-缓存机制"><a href="#其它-web-缓存机制" class="headerlink" title="其它 web 缓存机制"></a>其它 web 缓存机制</h2><p>1、数据库缓存<br>我们可能听说过 memcached ，它就是一种数据库层面的缓存方案。数据库缓存是指，当 web 应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><p>2、CDN 缓存<br>CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向 CDN 网关发起 Web 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个 CDN 就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><p>3、代理服务器缓存<br>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 Web 请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。</p><p>4、应用层缓存<br>应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前端开发中，浏览器缓存是 web 性能优化的重要方面，是提升 web 性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以对于缓存的应用需要综合考虑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="zhangjihu" scheme="http://xgfe.github.io/categories/zhangjihu/"/>
    
    
      <category term="缓存" scheme="http://xgfe.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="web 缓存" scheme="http://xgfe.github.io/tags/web-%E7%BC%93%E5%AD%98/"/>
    
      <category term="浏览器缓存" scheme="http://xgfe.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redux,react-redux简单实现</title>
    <link href="http://xgfe.github.io/2018/05/01/wangpan/redux-realize/"/>
    <id>http://xgfe.github.io/2018/05/01/wangpan/redux-realize/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2019-05-05T09:54:16.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在react项目中，如果你的UI层非常简单，没有很多的互动，那么redux是没有必要的。<br>redux是一个有用状态架构，所有的状态保存在一个对象中，对于大型的复杂应用， 代码结构和组件通信是极为关键的，而redux就是解决这两方面的问题。</p><h3 id="一、redux使用场景"><a href="#一、redux使用场景" class="headerlink" title="一、redux使用场景"></a>一、redux使用场景</h3><p><strong>适用redux的场景</strong>：</p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p><strong>从组件角度看</strong>:</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><h3 id="二、redux常用API"><a href="#二、redux常用API" class="headerlink" title="二、redux常用API"></a>二、redux常用API</h3><ul><li>createStore<store>()    创建stroe 返回store对象</store></li><li>store.getState<state>() 返回state</state></li><li>store.subscribe()       订阅store</li><li>store.dispatch()        提交状态变更的申请</li></ul><h3 id="三、redux简单实现"><a href="#三、redux简单实现" class="headerlink" title="三、redux简单实现"></a>三、redux简单实现</h3><p>整体架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscirbe</span>(<span class="params">listener</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始执行一次，获得初始化状态</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@first_init@wangpan'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState, subscribe, dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span> (<span class="params">creator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(creator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> bindAcitonCreators(creators, dispatch) &#123;</span><br><span class="line">    <span class="keyword">let</span> bound = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(creators).forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> creator = creators[v]</span><br><span class="line">        bound[v] = bindActionCreator(creator, dispatch)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>subcribe函数，传入监听函数，注意对参数校验，因为只是简单实现，我这就不写啦<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subscribe订阅函数 传入listener函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span> (<span class="params">listenr</span>) </span>&#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dispatch函数，传入action,同样可以对参数进行校验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    currentState = reducer(currentState, aciton)</span><br><span class="line">    <span class="comment">// state改变，执行订阅函数，这就是一个最基本的发布者订阅者模式</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v())</span><br><span class="line">    <span class="keyword">return</span> aciton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上一个最简单的redux就是实现了，现在暂且不实现redux中间件，下面我们看看react-redux实现</p><h3 id="四、react-redux简单实现"><a href="#四、react-redux简单实现" class="headerlink" title="四、react-redux简单实现"></a>四、react-redux简单实现</h3><p>在实现react-redux之前，先来看看react的context,这是实现react-redux的关键<br>在react父子组件通信是非常简单的，通过props就可以实现，但是在多层级的场景下通信通过props一层一层传递是非常麻烦而且不友好的,所以react提供context实现组件的跨多层级通信。</p><p>react-redux基本架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Proptypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindAcitonCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 负责链接组件，将redux中的数据放入组件</span></span><br><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect(mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> state, mapDispatchToProps = &#123;&#125;) =&gt;<span class="function">(<span class="params">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">            store: PropTpes.object</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">constructor</span> (props, context) &#123;</span><br><span class="line">            <span class="keyword">super</span>(props)</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                props: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update () &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            <span class="keyword">const</span> stateProps = mapStateToProps(store.getState())</span><br><span class="line">            <span class="keyword">const</span> dispatchProps = bindAcitonCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    ...this.state.props</span><br><span class="line">                    ...stateProps</span><br><span class="line">                    ...dispatchProps</span><br><span class="line">                    ...this.props</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// Provider组件，把strore放入context中，所有子元素可以直接去到store</span></span><br><span class="line"><span class="xml">export class Provider extends React.Component &#123;</span></span><br><span class="line"><span class="xml">    static childContextTypes = &#123;</span></span><br><span class="line"><span class="xml">        store: Proptypes.object</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    getchildContext () &#123;</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            store: this.store</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    constructor (props, context) &#123;</span></span><br><span class="line"><span class="xml">        super(props, context)</span></span><br><span class="line"><span class="xml">        this.store = props.store</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    render () &#123;</span></span><br><span class="line"><span class="xml">        return Children.only(this.props.children)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="五、中间件机制"><a href="#五、中间件机制" class="headerlink" title="五、中间件机制"></a>五、中间件机制</h3><p>在之前的redux基础上添加applyMiddleware函数，并且扩展crateStore函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果中间件存在</span></span><br><span class="line">    <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">        <span class="keyword">const</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> midApi = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch = middleware(midApi)(store, dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、redux-thunk简单实现"><a href="#六、redux-thunk简单实现" class="headerlink" title="六、redux-thunk简单实现"></a>六、redux-thunk简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><p>以上就基本实现了一个最简单的redux和react-redux</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpan" scheme="http://xgfe.github.io/categories/wangpan/"/>
    
    
      <category term="react" scheme="http://xgfe.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>动画库 Lottie 的使用</title>
    <link href="http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/"/>
    <id>http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/</id>
    <published>2018-04-26T08:26:00.000Z</published>
    <updated>2019-05-05T02:41:48.398Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍动画开源库 Lottie 在 Android 中的使用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常APP开发中，为了提升用户感官舒适度等原因，我们会在APP中加入适量动画。<br>而传统手写动画方式往往存在诸多问题:</p><ul><li><p><strong>动画复杂而实现困难</strong></p></li><li><p><strong>图片素材占用体积过大</strong></p></li><li><p><strong>不同Native平台都需各自实现，开发成本高</strong></p></li><li><p><strong>不同Native平台实现的最终效果不一致</strong></p></li><li><p><strong>后期视觉联调差异化大</strong></p></li></ul><p><img src="http://p0.meituan.com/tuanpic/lottie_android_headache.jpeg" alt="">  </p><p><em>难道就没有一种简便且高效的方案来减缓或解决上述问题吗？</em></p><p>答: 有的，那就是本文要介绍的主角 <strong>Lottie</strong>。</p><h2 id="一、Lottie-是什么？"><a href="#一、Lottie-是什么？" class="headerlink" title="一、Lottie 是什么？"></a>一、Lottie 是什么？</h2><blockquote><p>Lottie是Airbnb开源的一个面向IOS、Android、React Native的动画库，可以解析用 Adobe After Effects 制作动画后通过 Bodymovin 插件导出的 Json 数据文件并在移动端原生渲染。</p></blockquote><p>通俗点说，它是一款动画开源库，通过解析特定的Json文件或Json文本，可直接在移动端上渲染出复杂的动画效果。</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_flow.png" alt="参考图释"></p><h2 id="二、Lottie-能干什么"><a href="#二、Lottie-能干什么" class="headerlink" title="二、Lottie 能干什么?"></a>二、Lottie 能干什么?</h2><p><strong>它可以简便高效的实现复杂动画，替代传统低效的手写动画方式。</strong> </p><p>动画展示:</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_example_4.gif" alt=""></p><p>上方的动画是通过Lottie直接实现的。</p><p>如果我们使用手写代码方式实现，可以说是很难！  </p><p>而通过 Lottie 实现时，需要的仅是一个Json文件或一段Json文本，并通过简洁的代码集成即可。</p><p>集成代码可能精简到如下模样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/anim_lottie"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、为什么使用-Lottie"><a href="#三、为什么使用-Lottie" class="headerlink" title="三、为什么使用 Lottie?"></a>三、为什么使用 Lottie?</h2><ul><li><p><strong>简便，开发成本低</strong><br>相对于传统方式，动画不再是全部手写，所需做得只是嵌入XML并配置动画属性，集成快，开发时间少，开发成本低。    </p></li><li><p><strong>不同 Native 平台效果基本一致</strong><br>渲染交由Lottie引擎内部实现，无需开发者处理平台差异，多平台共用同一个动画配置文件，效果一致性高。    </p></li><li><p><strong>占用包体积小</strong><br>Lottie配置文件由Json文本串构成，相对于图片，占用体积更小。</p></li><li><p><strong>动画效果不失真</strong><br>传统图片拉伸或压缩导致失真，而Lottie为矢量图展示，不会出现失真情况。</p></li><li><p><strong>动画效果可以云端控制</strong><br>由于Lottie动画基于Json文件或文本解析，因此可以实现云端下发，实现动态加载，动态控制动画样式。</p></li></ul><h2 id="四、如何使用-Lottie？"><a href="#四、如何使用-Lottie？" class="headerlink" title="四、如何使用 Lottie？"></a>四、如何使用 Lottie？</h2><p>Lottie 仅支持用 Gradle 构建配置，最低支持安卓版本 16。     </p><h3 id="1-添加依赖到-build-gradle"><a href="#1-添加依赖到-build-gradle" class="headerlink" title="1. 添加依赖到 build.gradle"></a>1. 添加依赖到 build.gradle</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.airbnb.android:lottie:2.5.4'</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">"com.airbnb.android:lottie:$&#123;全局版本变量&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-添加-Adobe-After-Effects-导出的动画-Json-文件"><a href="#2-添加-Adobe-After-Effects-导出的动画-Json-文件" class="headerlink" title="2. 添加 Adobe After Effects 导出的动画 Json 文件"></a>2. 添加 Adobe After Effects 导出的动画 Json 文件</h3><p>通常由视觉工程师确认动效后通过AE导出, 我们只需将该Json文件保存至 /raw 或 /assets文件夹下。  </p><h3 id="3-XML中嵌入基本布局"><a href="#3-XML中嵌入基本布局" class="headerlink" title="3. XML中嵌入基本布局"></a>3. XML中嵌入基本布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-加载播放动画，两类方式可选"><a href="#4-加载播放动画，两类方式可选" class="headerlink" title="4. 加载播放动画，两类方式可选"></a>4. 加载播放动画，两类方式可选</h3><h4 id="①-XML中静态配置-举例"><a href="#①-XML中静态配置-举例" class="headerlink" title="① XML中静态配置, 举例:"></a>① XML中静态配置, 举例:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">       </span></span><br><span class="line"><span class="tag">    //加载方式如下<span class="attr">2</span>种任选其一</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/hello_world"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_fileName</span>=<span class="string">"hello_world.json"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //循环播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    //加载完毕后自动播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②-代码动态配置-举例"><a href="#②-代码动态配置-举例" class="headerlink" title="② 代码动态配置, 举例:"></a>② 代码动态配置, 举例:</h4><p><em>如下代码会在后台异步加载动画文件，并在加载完成后开始渲染动画。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LottieAnimationView animationView = ...;</span><br><span class="line">animationView.setAnimation(R.raw.hello_world);</span><br><span class="line">animationView.loop(<span class="keyword">true</span>);</span><br><span class="line">animationView.playAnimation();</span><br></pre></td></tr></table></figure><h2 id="五、其他拓展使用"><a href="#五、其他拓展使用" class="headerlink" title="五、其他拓展使用"></a>五、其他拓展使用</h2><h3 id="1-直接解析Json文本串加载动画"><a href="#1-直接解析Json文本串加载动画" class="headerlink" title="1. 直接解析Json文本串加载动画"></a>1. 直接解析Json文本串加载动画</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JsonReader jsonReader = <span class="keyword">new</span> JsonReader(<span class="keyword">new</span> StringReader(jsonStr));</span><br><span class="line">lottieView.setAnimation(jsonReader);</span><br><span class="line">lottieView.playAnimation();</span><br><span class="line">或</span><br><span class="line">Cancellable cancellable = LottieComposition.Factory.fromJsonString(jsonStr, composition -&gt; &#123;</span><br><span class="line">            lottieView.setComposition(composition);</span><br><span class="line">            lottieView.playAnimation();</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//必要时取消进行中的异步操作</span></span><br><span class="line">cancellable.cancel();</span><br></pre></td></tr></table></figure><h3 id="2-配合网络下载，实现下载Json配置并动态加载"><a href="#2-配合网络下载，实现下载Json配置并动态加载" class="headerlink" title="2. 配合网络下载，实现下载Json配置并动态加载"></a>2. 配合网络下载，实现下载Json配置并动态加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;ResponseBody&gt; call = RetrofitComponent.fetchLottieConfig();<span class="comment">//伪代码</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//String json = response.body().string();</span></span><br><span class="line">                <span class="comment">//交由Lottie处理...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//do something.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-动画加载监听器"><a href="#3-动画加载监听器" class="headerlink" title="3. 动画加载监听器"></a>3. 动画加载监听器</h3><p>根据业务需要进行动画过程监听:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">animationView.addAnimatorUpdateListener((animation) -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something.</span></span><br><span class="line">&#125;);</span><br><span class="line">animationView.playAnimation();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (animationView.isAnimating()) &#123;</span><br><span class="line"><span class="comment">// do something.</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">animationView.setProgress(<span class="number">0.5f</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-LottieDrawable-的使用"><a href="#4-LottieDrawable-的使用" class="headerlink" title="4. LottieDrawable 的使用"></a>4. LottieDrawable 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LottieDrawable drawable = <span class="keyword">new</span> LottieDrawable();</span><br><span class="line">LottieComposition.Factory.fromAssetFileName(getApplicationContext(), <span class="string">"lottie_pin_jump.json"</span>, composition -&gt; &#123;</span><br><span class="line">            drawable.setComposition(composition);</span><br><span class="line">            <span class="comment">//目前显示为静态图</span></span><br><span class="line">            ivLottie.setImageDrawable(drawable);</span><br><span class="line">            <span class="comment">//调用start()开始播放动画</span></span><br><span class="line">            drawable.start();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="5-更多使用可参考文末官方链接"><a href="#5-更多使用可参考文末官方链接" class="headerlink" title="5. 更多使用可参考文末官方链接"></a>5. 更多使用可参考文末官方链接</h3><h2 id="六、需要考虑的问题"><a href="#六、需要考虑的问题" class="headerlink" title="六、需要考虑的问题"></a>六、需要考虑的问题</h2><ol><li>由于是依赖于AE做的动画，估计以后不只是要求视觉设计师精通AE，连前端开发都需要了解AE  </li><li>Lottie 对 Json 文件的支持待完善，目前存在部分AE导出成 Json 文件无法渲染或渲染不佳</li><li>支持的功能存在限制，可参考 <a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">功能支持列表</a>。</li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>尽管Lottie还存在诸多小问题，但它所带来的效率提升绝对是传统开发方式无法比拟的。我们要做的是正确善用它。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">官网网址</a><br><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Github地址</a><br><a href="https://github.com/airbnb/lottie-android/tree/master/LottieSample/src/main/assets" target="_blank" rel="noopener">测试用Json文件</a><br><a href="https://github.com/bigxixi/lottie-android" target="_blank" rel="noopener">项目中文翻译版 (略有差异)</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍动画开源库 Lottie 在 Android 中的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="w.p" scheme="http://xgfe.github.io/categories/w-p/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="animation" scheme="http://xgfe.github.io/tags/animation/"/>
    
      <category term="lottie" scheme="http://xgfe.github.io/tags/lottie/"/>
    
  </entry>
  
</feed>
